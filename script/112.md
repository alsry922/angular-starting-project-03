1. So Components have a host element.  
   컴포넌트는 호스트 요소를 가지고 있습니다.

2. Every Component has a host element,  
   and as you learn, it's simply the element that's targeted  
   by the Component selector.  
   모든 컴포넌트는 호스트 요소를 가지며,  
   이는 컴포넌트 선택자가 타겟팅하는 요소에 해당합니다.

3. Now this host element feature is really important  
   to understand.  
   호스트 요소 기능은 이해하는 데 매우 중요합니다.

4. It is important to understand  
   that what you select here is actually rendered to the dom.  
   여기에서 선택한 요소가 실제로 DOM에 렌더링된다는 것을  
   이해하는 것이 중요합니다.

5. That there is an app control element in the dom of the page  
   that's visited by the browser, for example.  
   예를 들어, 브라우저에서 방문한 페이지의 DOM에  
   app-control 요소가 존재합니다.

6. And we can often use this to our advantage.  
   그리고 우리는 종종 이를 활용할 수 있습니다.

7. For example, here in this control Component,  
   I wrap my label and NG content with this paragraph.  
   예를 들어, 이 control 컴포넌트에서  
   label과 NG content를 p 태그로 감쌉니다.

8. Now that is fine,  
   but if you then inspect this here,  
   you, of course, see that in that form  
   for every control we have app control,  
   so our host element.  
   이것은 괜찮지만, 이를 검사해 보면,  
   폼 안에 있는 각 control마다 app-control,  
   즉 호스트 요소가 있는 것을 확인할 수 있습니다.

9. And then in there the paragraph,  
   and then in there the label and the input.  
   그리고 그 안에는 p 태그가 있고,  
   그 안에 label과 input이 있습니다.

10. That of course works,  
    but this paragraph is kind  
    of an unnecessary element in there.  
    이것은 작동하지만, p 태그는  
    불필요한 요소처럼 보입니다.

11. We don't need that many levels of nesting here.  
    여기에서는 그렇게 많은 중첩이 필요하지 않습니다.

12. Why don't we just put the label  
    and input directly into this app control element?  
    label과 input을 그냥 app-control 요소에  
    직접 넣으면 어떨까요?

13. Well, we can of course do that.  
    물론 그렇게 할 수 있습니다.

14. We can remove this paragraph,  
    but if we do that, then we'll break our styles again,  
    because in the control Components CSS file,  
    I'm looking for elements with control as a class on them.  
    p 태그를 제거할 수 있지만,  
    그렇게 하면 스타일이 다시 깨질 것입니다.  
    왜냐하면 control 컴포넌트 CSS 파일에서는  
    control 클래스를 가진 요소를 찾고 있기 때문입니다.

15. So therefore, if I reload now, the styles are broken,  
    as you can tell.  
    그래서 지금 새로고침하면,  
    스타일이 깨진 것을 확인할 수 있습니다.

16. But of course you'll also already know the workaround.  
    하지만 이미 해결 방법도 알고 있을 것입니다.

17. Instead of targeting control here,  
    we can target colon host  
    so that we look for labels and inputs  
    and text areas inside of our host element,  
    so inside of the app dash control element.  
    여기에서 control 대신, :host를 타겟팅하여  
    호스트 요소, 즉 app-control 요소 안에 있는  
    label, input, text area를 찾을 수 있습니다.

18. And if we do that and save that,  
    it's still broken somehow.  
    그렇게 하고 저장하면 여전히 깨져 있습니다.

19. Well now it's broken here  
    because for this component,  
    we disabled view encapsulation, we set it to none.  
    이는 이 컴포넌트에서 view encapsulation을 비활성화하고  
    none으로 설정했기 때문입니다.

20. Now as a result, this component,  
    of course, still has a host element.  
    이 결과로, 이 컴포넌트는 여전히 호스트 요소를 가지고 있습니다.

21. We saw that in the dom before. It is there.  
    우리는 이전에 DOM에서 이를 확인했습니다.

22. But this host CSS selector won't work  
    because these styles  
    of this component are indeed no longer scoped  
    to this component.  
    하지만 이 host CSS 선택자는 작동하지 않습니다.  
    왜냐하면 이 컴포넌트의 스타일은 더 이상  
    이 컴포넌트에 한정되지 않기 때문입니다.

23. Instead, they are applied as global styles  
    to the entire page  
    as if you would've put them  
    into the styles.CSS file in the end.  
    대신, 마치 styles.CSS 파일에 추가한 것처럼  
    이 스타일이 페이지 전체에 글로벌 스타일로 적용됩니다.

24. And therefore there is no real connection  
    between these styles and these CSS rules  
    and the component to which you attach them.  
    따라서 이러한 스타일과 CSS 규칙,  
    그리고 이를 연결하려는 컴포넌트 간에  
    실제 연결이 없습니다.

25. That's why this host selector doesn't target  
    this component's host element  
    with view encapsulation set to none.  
    그래서 view encapsulation을 none으로 설정한 경우  
    host 선택자가 이 컴포넌트의 호스트 요소를  
    타겟팅하지 않습니다.

26. So for this specific use case,  
    we can't use this host selector,  
    but we can do something else.  
    따라서 이 특정 사용 사례에서는 host 선택자를  
    사용할 수 없지만, 다른 방법을 사용할 수 있습니다.

27. I'll go back to using dot control  
    and we could now go to the place  
    where we use app control.  
    다시 .control을 사용하고,  
    app-control을 사용하는 위치로 이동하겠습니다.

28. So here in the new ticket Component HTML file.  
    여기에서는 new-ticket 컴포넌트 HTML 파일입니다.

29. And add this control class here  
    because you can add extra attributes like this  
    on your Components.  
    여기에서 control 클래스를 추가할 것입니다.  
    컴포넌트에 이처럼 추가 속성을  
    추가할 수 있기 때문입니다.

30. Even if they're not inputs of those Components,  
    you can still add any attributes you want.  
    그것이 컴포넌트의 입력 속성이 아니더라도  
    원하는 속성을 추가할 수 있습니다.

31. They often just might not have any effect.  
    다만, 대부분의 경우 효과가 없을 수도 있습니다.

32. But here it will have an effect  
    because by adding a class here, we're adding this class,  
    which is wanted by the control Component CSS file.  
    하지만 여기에서는 효과가 있습니다.  
    왜냐하면 클래스를 추가함으로써,  
    control 컴포넌트 CSS 파일이 필요로 하는  
    클래스를 추가하기 때문입니다.

33. So by adding this class here  
    to app control in the new ticket Component template,  
    if you save it, you'll get back the look you had before.  
    따라서 new-ticket 컴포넌트 템플릿의  
    app-control에 이 클래스를 추가하고 저장하면  
    이전 스타일을 다시 복원할 수 있습니다.

34. So that is a possible solution  
    and it's important to understand  
    that you can add any attributes of your choice  
    to your own elements.  
    이것이 하나의 해결 방법이며,  
    자신만의 요소에 원하는 속성을 추가할 수 있다는 점을  
    이해하는 것이 중요합니다.

---

끝났습니다.
