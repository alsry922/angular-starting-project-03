네, 대본을 문장별로 번역하겠습니다:

1. So you did now learn about more lifecycle hooks and about ViewChild and ContentChild.

이제 여러분은 더 많은 라이프사이클 훅들과 ViewChild, ContentChild에 대해 배웠습니다.

2. Before we continue working on that new ticket component and we make sure that we actually use
   the submitted values to advance our application, there's one last kind of lifecycle related feature
   I also want to introduce you to, though it's not technically a lifecycle hook instead it's a Signal feature.

새로운 티켓 컴포넌트 작업을 계속하고 제출된 값들을 실제로 애플리케이션 발전에 사용하기 전에,
여러분께 소개하고 싶은 마지막 라이프사이클 관련 기능이 하나 있습니다.
비록 이것은 기술적으로 라이프사이클 훅은 아니고 Signal 기능입니다.

3. And to understand it, I'll go to the server status component.

이것을 이해하기 위해, server status 컴포넌트로 이동하겠습니다.

4. In there in my application, I'm currently not using a Signal, but I'll change that now.

제 애플리케이션에서 현재 Signal을 사용하고 있지 않지만, 이제 그것을 변경하겠습니다.

5. I'll change the current status property from being a regular property to being a Signal by executing
   the Signal function provided by Angular core.

Angular core에서 제공하는 Signal 함수를 실행하여 current status 속성을 일반 속성에서 Signal로 변경하겠습니다.

6. So I want to manage my state here with help of signals now.

이제 signals의 도움을 받아 여기서 상태를 관리하고 싶습니다.

7. For that, I'll initialize this Signal to the value offline and therefore current status now will hold
   a Signal as a value.

이를 위해, 이 Signal을 offline 값으로 초기화하겠습니다. 따라서 current status는 이제 Signal을 값으로 가지게 됩니다.

8. And hence the type of current status is no longer one of these strings, but instead it's a writeable Signal.

따라서 current status의 타입은 더 이상 이러한 문자열 중 하나가 아니라, 대신 writeable Signal입니다.

9. But I'll take advantage of the fact that I can overwrite the inferred type of the value wrapped by
   that Signal by adding angle brackets here.

하지만 저는 여기에 angle brackets을 추가하여 Signal에 의해 래핑된 값의 추론된 타입을 덮어쓸 수 있다는
사실을 활용하겠습니다.

10. And I'll tell TypeScript that the value managed by that Signal is not any kind of string, which would
    be its inferred value, but instead that it's one of these three strings.

그리고 TypeScript에게 해당 Signal이 관리하는 값이 추론된 값인 임의의 문자열이 아니라,
이 세 가지 문자열 중 하나라고 알려주겠습니다.

11. Initially it's offline, but it could be online or unknown.

초기값은 offline이지만, online이나 unknown이 될 수 있습니다.

12. So now current status is a Signal.

이제 current status는 Signal입니다.

13. Therefore if you want to update it, we have to do that with help of the set method.

따라서 이것을 업데이트하려면 set 메서드의 도움을 받아야 합니다.

14. So in all those places where I change the Signal value, that's now done with set.

그래서 Signal 값을 변경하는 모든 곳에서, 이제 set으로 수행됩니다.

15. And in the template we now have to read that.

그리고 이제 템플릿에서 이것을 읽어야 합니다.

16. So we have to execute current status as a function.

따라서 current status를 함수로 실행해야 합니다.

17. Like this.

이렇게 말입니다.

18. With that if we save that, all this application still works the way it did before, but now I'm using
    a Signal in the server status component.

이것을 저장하면, 이 애플리케이션은 여전히 이전처럼 작동하지만, 이제 server status 컴포넌트에서
Signal을 사용하고 있습니다.

19. Now why am I doing that though?

그런데 왜 제가 이렇게 하는 걸까요?

20. Well, because sometimes you have code that should be executed whenever a Signal value changes.

음, 때때로 Signal 값이 변경될 때마다 실행되어야 하는 코드가 있기 때문입니다.

21. Now, if you're using a Signal in a template like I'm doing it here in multiple places, Angular will
    automatically set up and manage a subscription for you and it'll automatically update the template whenever
    the Signal value changes.

이제, 제가 여기 여러 곳에서 하는 것처럼 템플릿에서 Signal을 사용하는 경우, Angular는 자동으로
구독을 설정하고 관리하며, Signal 값이 변경될 때마다 템플릿을 자동으로 업데이트합니다.

22. But what if you wanna listen to a change in your TypeScript component class?

하지만 TypeScript 컴포넌트 클래스에서 변경사항을 듣고 싶다면 어떨까요?

23. There let's say in the constructor, if I read this Signal value like this, Angular will not set up
    a subscription.

생성자에서, 이렇게 Signal 값을 읽으면 Angular는 구독을 설정하지 않습니다.

24. Instead, if I read it like this and I reload here, you will see that offline gets logged here.

대신, 이렇게 읽고 여기서 리로드하면, offline이 여기에 로그되는 것을 볼 수 있습니다.

25. That's coming from that server status component, TypeScript file from the constructor there.

이것은 server status 컴포넌트의 TypeScript 파일, 거기의 생성자에서 오는 것입니다.

26. But then we never see any other offline, online or unknown log thereafter.

하지만 그 후에는 다른 offline, online 또는 unknown 로그를 전혀 보지 못합니다.

27. We only have this one log.

우리는 이 하나의 로그만 가지고 있습니다.

28. And the reason for that is that, as I just explained, Angular does not set up a subscription here,
    which is good.

그리고 그 이유는 제가 방금 설명했듯이, Angular가 여기서 구독을 설정하지 않기 때문입니다.
이는 좋은 것입니다.

29. That means you can safely read Signal values in your TypeScript code without setting up accidental subscriptions.

이는 우발적인 구독을 설정하지 않고도 TypeScript 코드에서 안전하게 Signal 값을 읽을 수 있다는 것을 의미합니다.

30. But the downside is that sometimes you might want to set up a subscription and you're not getting
    it then, that's why Angular offers you a special function.

하지만 단점은 때때로 구독을 설정하고 싶어도 얻지 못할 수 있다는 것입니다.
그래서 Angular는 특별한 함수를 제공합니다.

31. The effect function, which is of course imported from Angular core, which you can execute in your
    constructor for example.

물론 Angular core에서 임포트되는 effect 함수는 예를 들어 생성자에서 실행할 수 있습니다.

32. And effect takes a function as an argument.

그리고 effect는 함수를 인자로 받습니다.

33. And if you then use a Signal in that function that's passed to effect, Angular will set up a subscription.

그리고 effect에 전달된 함수에서 Signal을 사용하면, Angular가 구독을 설정할 것입니다.

34. So by moving this code into this function that's passed to effect, Angular now does set up a subscription.

따라서 이 코드를 effect에 전달된 이 함수로 이동함으로써, Angular는 이제 구독을 설정합니다.

35. And it it'll automatically clean up that subscription if that component should ever get removed from the dorm.

그리고 해당 컴포넌트가 DOM에서 제거되면 자동으로 그 구독을 정리할 것입니다.

36. But with that, if I now save that and I reload, you'll see that now I got offline here and we'll get
    new logs from time to time like here with online whenever this Signal value changes.

하지만 이것으로, 이제 저장하고 리로드하면, 여기서 offline을 얻었고 Signal 값이 변경될 때마다
여기 online처럼 때때로 새로운 로그를 얻을 것입니다.

37. And that can be a useful feature.

그리고 이것은 유용한 기능이 될 수 있습니다.

38. And therefore, whilst effect is not technically a lifecycle hook, it's a very important function you
    should at least know about because it does allow you to run code when Signal values change, which you
    might not need all the time, but which you might need sometimes.

따라서, effect가 기술적으로 라이프사이클 훅은 아니지만, Signal 값이 변경될 때 코드를 실행할 수
있게 해주기 때문에 최소한 알아야 할 매우 중요한 함수입니다. 항상 필요하지는 않을 수 있지만,
때때로 필요할 수 있습니다.

39. And that's therefore how you can use that effect function.

그리고 따라서 이것이 effect 함수를 사용하는 방법입니다.

번역이 완료되었습니다.
