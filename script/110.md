1. **Now I wanna dive into additional**  
   **Angular features about which you should know**  
   **by fixing this control component.**  
   이제 `control` 컴포넌트를 수정하면서  
   알아야 할 추가적인 Angular 기능에 대해  
   살펴보겠습니다.

2. **In the control component CSS file**  
   **I'm looking for the control class on elements**  
   **and then I'm trying to style labels, inputs,**  
   **and text areas that are nested inside of an element**  
   **with the class control.**  
   `control.component` CSS 파일에서는  
   `control` 클래스를 가진 요소를 찾은 다음,  
   해당 요소 내부에 있는 `label`, `input`,  
   그리고 `textarea`를 스타일링하려고 합니다.

3. **Well, they offer what we could**  
   **and should do to fix this broken look of this form is**  
   **we should go to the control component HTML file.**  
   이 폼의 깨진 스타일을 수정하려면  
   `control.component` HTML 파일로 이동해야 합니다.

4. **And there on the paragraph we can add**  
   **this control class.**  
   그리고 해당 단락에  
   `control` 클래스를 추가할 수 있습니다.

5. **With that if we do that, it's fixed to some extent.**  
   이렇게 하면 어느 정도 문제가 해결됩니다.

6. **The label looks better now, which is a start,**  
   **but the input and text area isn't looking**  
   **the way it should look.**  
   레이블은 더 나아졌지만,  
   `input`과 `textarea`는 여전히  
   원하는 모양대로 보이지 않습니다.

7. **It doesn't look horrible, but it doesn't have the look**  
   **it should have.**  
   완전히 이상하진 않지만,  
   기대했던 모양은 아닙니다.

---

계속 이어가겠습니다.

8. **And why is that the case?**  
   **After all, we have this rule here, right?**  
   그렇다면 왜 이런 문제가 발생할까요?  
   분명히 여기 규칙이 있는데 말이죠.

9. **Well yes, but with this CSS rule,**  
   **we are trying to style inputs and text areas**  
   **that are inside of an element**  
   **with the class control on it.**  
   맞습니다. 그러나 이 CSS 규칙은  
   `control` 클래스를 가진 요소 내부의  
   `input`과 `textarea`를 스타일링하려고 합니다.

10. **And you might say that's the case here**  
    **because we project inputs**  
    **and text areas here in place of this NG content element,**  
    **and therefore they will be inside of an element**  
    **with a class of control.**  
    그리고 `ng-content` 요소 대신  
    `input`과 `textarea`를 투영하기 때문에  
    이들이 `control` 클래스를 가진 요소 내부에  
    있다고 말할 수 있습니다.

11. **So these styles here should become active on them, right?**  
    **Yeah, almost.**  
    그래서 이 스타일이 활성화되어야 맞을 텐데요, 맞죠?  
    네, 거의 맞습니다.

12. **The problem is Angular does not care about which content**  
    **might eventually end up in your components template.**  
    **It only cares about what it sees in your component template,**  
    **and there it just sees a placeholder,**  
    **not the actual inputs or text areas that will end up here**  
    **in the future.**  
    문제는 Angular는 나중에  
    컴포넌트 템플릿에 포함될 콘텐츠가 무엇인지  
    신경 쓰지 않는다는 점입니다.  
    Angular는 오직 컴포넌트 템플릿에서  
    현재 보이는 것만 처리하며,  
    여기서는 실제 `input`이나 `textarea` 대신  
    단순히 자리 표시자만 인식합니다.

---

계속 이어가겠습니다.

13. **And that's why these styles won't affect the inputs**  
    **and text areas that will be projected into this paragraph**  
    **and into this component.**  
    그래서 이러한 스타일이  
    이 단락이나 컴포넌트에 투영될  
    `input`과 `textarea`에 영향을 미치지 않는 것입니다.

14. **So what can we do about that?**  
    그렇다면 이를 해결하려면 어떻게 해야 할까요?

15. **Well you can disable the scoping of these styles**  
    **here for example, because by default, as I explained,**  
    **component styles are scoped to the component**  
    **to which they belong.**  
    여기서는 스타일 스코핑을 비활성화할 수 있습니다.  
    기본적으로 컴포넌트 스타일은  
    해당 컴포넌트로 제한되기 때문입니다.

16. **They can't affect anything else anywhere**  
    **in any other component.**  
    이는 다른 컴포넌트나 다른 곳에  
    영향을 미칠 수 없도록 설정되어 있습니다.

17. **But here I actually wanna have these styles affect inputs**  
    **and text areas that are somewhere else in the application.**  
    그러나 여기서는 이 스타일이  
    애플리케이션의 다른 위치에 있는  
    `input`과 `textarea`에도 영향을 주길 원합니다.

18. **And therefore what we should do here or what we could do**  
    **to fix this problem is go to the component selector**  
    **of the control component**  
    **and add a new setting here.**  
    따라서 문제를 해결하기 위해  
    `control` 컴포넌트의 셀렉터로 이동하여  
    새 설정을 추가해야 합니다.

19. **And the new setting you want to add**  
    **is the encapsulation setting.**  
    추가해야 할 새 설정은  
    `encapsulation` 설정입니다.

20. **And encapsulation takes a value of type view encapsulation.**  
    **And that is actually a so-called enum,**  
    **which is essentially a collection of possible values.**  
    `encapsulation`은 `ViewEncapsulation` 유형의  
    값을 받습니다.  
    이는 가능한 값의 집합을 의미하는  
    일종의 열거형(enum)입니다.

---

계속 이어가겠습니다.

21. **It's a TypeScript feature which is used by Angular here.**  
    이는 TypeScript의 기능으로,  
    Angular에서 사용됩니다.

22. **You can and should import ViewEncapsulation**  
    **from Angular core and then by adding a dot here**  
    **you can access the different values you can use.**  
    `@angular/core`에서 `ViewEncapsulation`을  
    임포트한 후, 점(`.`)을 추가하여  
    사용할 수 있는 다양한 값을 확인할 수 있습니다.

23. **Now emulated would be the default**  
    **and you don't need to set it.**  
    기본값은 `Emulated`이며,  
    설정할 필요가 없습니다.

24. **Emulated means that Angular emulates the ShadowDom behavior,**  
    **which is a browser thing, which in the end means that styles**  
    **that belong to a component or to an element should be scoped**  
    **to that element.**  
    `Emulated`는 Angular가  
    브라우저의 `Shadow DOM` 동작을 에뮬레이션하며,  
    이는 특정 컴포넌트나 요소에 속한 스타일이  
    해당 요소에만 제한된다는 것을 의미합니다.

25. **The ShadowDom is not a TypeScript**  
    **or Angular specific feature.**  
    `Shadow DOM`은 TypeScript나 Angular의  
    고유 기능이 아닙니다.

26. **Instead it's a browser feature**  
    **because in the browser you can also build**  
    **custom HTML elements totally without Angular.**  
    이는 브라우저 기능이며,  
    Angular 없이도 브라우저에서  
    사용자 정의 HTML 요소를 만들 수 있습니다.

27. **And Angular emulates that browser feature**  
    **for its own components.**  
    Angular는 이러한 브라우저 기능을  
    자체 컴포넌트에서 에뮬레이션합니다.

28. **Alternatively, you could choose ShadowDom**  
    **so that Angular under the hood uses the real**  
    **browser ShadowDom feature,**  
    **which is not supported by all browsers though,**  
    **which is why emulated is the default.**  
    대안으로 `ShadowDom`을 선택하여  
    Angular가 실제 브라우저의 `Shadow DOM` 기능을  
    사용할 수 있습니다.  
    그러나 모든 브라우저가 이를 지원하지 않으므로  
    `Emulated`가 기본값으로 설정되어 있습니다.

---

계속 이어가겠습니다.

29. **But here we need none,**  
    **which simply disables that style scoping,**  
    **that style encapsulation as Angular calls it.**  
    그러나 여기에서는 `None`이 필요합니다.  
    이는 스타일 스코핑, 즉 Angular에서 말하는  
    스타일 캡슐화를 비활성화합니다.

30. **With that setting added here to this control component,**  
    **the styles set up here will again become global styles**  
    **and therefore now they will affect the input and text area**  
    **that is eventually rendered into this component.**  
    이 설정을 `control` 컴포넌트에 추가하면,  
    해당 스타일이 다시 글로벌 스타일로 작동하게 됩니다.  
    따라서 최종적으로 이 컴포넌트에 렌더링되는  
    `input`과 `textarea`에도 영향을 미칩니다.

31. **And that's therefore another important feature to know.**  
    이는 반드시 알아야 할 중요한 기능입니다.

32. **You will typically not need to disable**  
    **encapsulation that often,**  
    **but if you do need to, like here in this example,**  
    **this is how you can do it.**  
    일반적으로 스타일 캡슐화를 비활성화할 일은  
    자주 발생하지 않겠지만,  
    이 예제처럼 필요할 때는  
    이렇게 설정하면 됩니다.

---

**번역이 완료되었습니다.**
