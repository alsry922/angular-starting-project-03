1. **So now that we added a bunch of components**  
   **and we played around with ng-content quite a bit,**  
   이제 여러 컴포넌트를 추가하고  
   `ng-content`를 많이 활용해 봤으니,

2. **there is another reusable component I wanna add**  
   **to this application.**  
   이 애플리케이션에 또 다른  
   재사용 가능한 컴포넌트를 추가하려고 합니다.

3. **And that's a component that should deal with those inputs**  
   **because again, here we have a similar shape of markup,**  
   **which we're reusing.**  
   그리고 이는 입력 필드를 처리하는 컴포넌트로,  
   여기서 비슷한 형태의 마크업을  
   재사용하고 있기 때문입니다.

4. **Now, of course, we're only using it in two places,**  
   **and you definitely don't need to start creating components**  
   **for every piece of markup that looks similar.**  
   물론, 우리는 현재 이를 두 곳에서만 사용하고 있으며,  
   비슷한 마크업이 있다고 해서  
   반드시 컴포넌트를 생성해야 하는 것은 아닙니다.

5. **But since we're in a course and for practice purposes**  
   **and to also dive**  
   **into some other more advanced Angular features,**  
   **I will create yet another reusable component**  
   **for these controls here, which I have in my form.**  
   하지만 현재는 학습 과정에 있고,  
   연습과 더 고급 Angular 기능을 다루기 위해  
   폼에 있는 이 컨트롤을 위한 또 다른  
   재사용 가능한 컴포넌트를 생성하려고 합니다.

6. **And therefore, I'll again, generate a new component**  
   **in that shared folder, which I'll name control**  
   **because it should be a form control in the end.**  
   그래서 `shared` 폴더 안에  
   `control`이라는 새로운 컴포넌트를 생성하겠습니다.  
   이는 최종적으로 폼 컨트롤이 될 것입니다.

---

계속 이어가겠습니다.

7. **It should be a component that outputs some form element.**  
   이 컴포넌트는 폼 요소를 출력해야 합니다.

8. **Now, I forgot to add skip tests,**  
   **which is why I have this test file here, which I'll remove.**  
   테스트 생성을 생략하는 옵션을 추가하지 않아서  
   테스트 파일이 생성되었는데, 이를 제거하겠습니다.

9. **And I'll now work on this control.component.**  
   이제 `control.component` 작업을 시작하겠습니다.

10. **And my idea with that component**  
    **is that we grab such a paragraph, which contains a label**  
    **and an input or a text area, and we copy that**  
    **and we use that as a template**  
    **in the control.component template HTML file.**  
    이 컴포넌트의 목적은  
    레이블과 입력 필드 또는 텍스트 영역을 포함한 단락을 가져와  
    이를 복사하고  
    `control.component`의 템플릿 파일에  
    템플릿으로 사용하는 것입니다.

11. **But, of course, now both the label text,**  
    **as well as the input is dynamic**  
    **and should be settable from outside**  
    **to make this control.component reusable.**  
    물론 레이블 텍스트와 입력 필드는 동적으로 설정되어야 하며,  
    외부에서 설정 가능하도록 만들어야  
    `control.component`가 재사용 가능합니다.

12. **Now, for the label, I'll use an input.**  
    레이블에는 `@Input`을 사용하겠습니다.

13. **We could also use ng-content and select different things,**  
    **but to mix things up,**  
    **and since it's just a short, simple string,**  
    **I'll use an input here, but either approach would be fine.**  
    `ng-content`를 사용해 다른 요소를 선택할 수도 있지만,  
    다양성을 위해, 그리고 간단한 짧은 문자열이므로  
    여기서는 `@Input`을 사용하겠습니다.  
    하지만 어느 접근 방식이든 괜찮습니다.

14. **So here in the ControlComponent class, we can**  
    **and should register an input either with @Input,**  
    **as you learned, or through the input function,**  
    **which is what I'll use here.**  
    따라서 `ControlComponent` 클래스에서  
    `@Input` 또는 `input` 함수를 사용해  
    입력값을 등록해야 합니다.  
    여기서는 `input` 함수를 사용할 것입니다.

---

계속 이어가겠습니다.

15. **And I'll name my input label**  
    **and then call that input function.**  
    입력값 이름을 `label`로 설정하고,  
    `input` 함수를 호출하겠습니다.

16. **And actually, this should be a required input**  
    **where I'll get a string.**  
    이 입력값은 필수 입력값으로 설정하며,  
    문자열 값을 받을 것입니다.

17. **And then in the ControlComponent template,**  
    **instead of outputting the hard-coded text Title,**  
    **I wanna use string interpolation**  
    **and output my label input value here.**  
    그런 다음 `ControlComponent` 템플릿에서  
    하드코딩된 텍스트인 `Title` 대신,  
    문자열 보간을 사용하여  
    입력값 `label`을 출력하겠습니다.

18. **And since I'm using the input function, it's a signal**  
    **and I need to add those parentheses.**  
    `input` 함수를 사용했으므로, 이는 Signal이며,  
    괄호를 추가해야 합니다.

19. **If I would use the @Input decorator,**  
    **you would not add them, but with signals, you need them.**  
    `@Input` 데코레이터를 사용할 경우에는  
    괄호를 추가하지 않아도 되지만,  
    Signal을 사용할 때는 필요합니다.

20. **But what about this input element here now?**  
    **It has a name and an id,**  
    **and it might receive even input-specific attributes**  
    **in the future.**  
    하지만 이제 이 입력 요소는 어떻게 할까요?  
    이 요소에는 `name`과 `id`가 있으며,  
    향후 입력 요소에 특화된  
    속성을 받을 수도 있습니다.

21. **Therefore, of course, we could start accepting them all**  
    **as inputs here.**  
    따라서 이러한 모든 속성을  
    입력값으로 받을 수 있습니다.

22. **But we would potentially end up**  
    **with a pretty long list of inputs.**  
    하지만 그렇게 하면,  
    매우 긴 입력값 목록이 생길 가능성이 있습니다.

23. **And whenever we wanted to make a new attribute**  
    **of this input element configurable,**  
    **we would have to add a new input to the component.**  
    그리고 입력 요소의 새 속성을  
    설정 가능하게 만들 때마다  
    컴포넌트에 새 입력값을 추가해야 합니다.

---

계속 이어가겠습니다.

24. **In addition, it's not always an input,**  
    **which I wanna output here.**  
    **Instead, I also have a textarea here,**  
    **so that therefore screams**  
    **for ng-content here in the control.component.**  
    또한, 여기서 항상 출력해야 하는 것이  
    입력 필드만 있는 것은 아닙니다.  
    대신 텍스트 영역(`textarea`)도 있으므로,  
    이는 `control.component`에서  
    `ng-content`를 사용할 필요가 있다는 신호입니다.

25. **Because ng-content allows us to insert any kind**  
    **of markup here into this component**  
    **from inside the place where we're using this component.**  
    `ng-content`를 사용하면,  
    컴포넌트를 사용하는 위치에서  
    이 컴포넌트 내부로  
    어떤 종류의 마크업이든 삽입할 수 있습니다.

26. **However, I actually wanna be a bit restrictive regarding**  
    **what can be inserted here, and I'll use select for that.**  
    하지만 이 컴포넌트에 삽입할 수 있는 내용을  
    약간 제한하고 싶으며, 이를 위해 `select`를 사용하겠습니다.

27. **Because you cannot just use this select property**  
    **on ng-content if you have multiple ng-contents,**  
    **though that is a common use case.**  
    `select` 속성은 `ng-content`가 여러 개 있을 때  
    사용하는 것이 일반적이지만,  
    여기서는 단일 `ng-content`에 대해서도 사용할 수 있습니다.

28. **But you can also use it**  
    **to be well, selective about which kind of content**  
    **can be projected into one of your components**  
    **to make sure that it's not used in an incorrect way**  
    **or that it at least doesn't work then.**  
    이를 통해 특정 유형의 콘텐츠만  
    컴포넌트에 투영되도록 선택할 수 있습니다.  
    이를 통해 컴포넌트가 올바르지 않게 사용되거나  
    의도치 않은 방식으로 작동하지 않도록 할 수 있습니다.

29. **So here I wanna select input elements**  
    **and textarea elements, and that is new.**  
    여기서는 `input` 요소와 `textarea` 요소만 선택하려고 합니다.  
    이는 새로운 접근 방식입니다.

30. **You can specify multiple selectors here,**  
    **separated by a comma.**  
    여러 셀렉터를 쉼표로 구분하여  
    지정할 수 있습니다.

---

계속 이어가겠습니다.

31. **And here I have multiple element selectors.**  
    여기서는 여러 요소 셀렉터를 사용하고 있습니다.

32. **You could, by the way, do something similar**  
    **for component selectors.**  
    참고로, 컴포넌트 셀렉터에서도  
    비슷한 작업을 수행할 수 있습니다.

33. **Here if we maybe also want to support anchor tags**  
    **with appButton on them, we could add a comma**  
    **and add this selector here to the list of selectors.**  
    예를 들어, `appButton` 속성이 있는  
    앵커 태그를 지원하고 싶다면,  
    쉼표를 추가한 뒤 해당 셀렉터를  
    셀렉터 목록에 추가할 수 있습니다.

34. **So for component selectors**  
    **and for ng-content select,**  
    **you can specify multiple selectors**  
    **by separating them with a comma.**  
    컴포넌트 셀렉터와  
    `ng-content`의 `select` 속성 모두에서  
    쉼표로 구분하여  
    여러 셀렉터를 지정할 수 있습니다.

35. **And I'll leave that selector list here**  
    **for my button.component,**  
    **even though I don't use any anchor tags**  
    **with appButton in this application**  
    **just so that you see that you can also have lists**  
    **of selectors here.**  
    현재 애플리케이션에서  
    `appButton` 속성을 가진 앵커 태그를 사용하지 않더라도,  
    이를 보여주기 위해  
    `button.component`의 셀렉터 목록에  
    그대로 남겨두겠습니다.

36. **But back to the control.component,**  
    **I'm now using this feature to make sure that only inputs**  
    **or textareas are selected**  
    **and any other content doesn't end up in this template.**  
    다시 `control.component`로 돌아와서,  
    입력 필드와 텍스트 영역만 선택되도록 하고  
    다른 콘텐츠는 이 템플릿에 포함되지 않도록  
    이 기능을 사용하고 있습니다.

37. **Well, and with that, we can now use this control.component.**  
    이제 이 `control.component`를 사용할 수 있습니다.

38. **We can go to the new-ticket.component.html file**  
    **and replace this paragraph here**  
    **with app-control also for the closing tag.**  
    `new-ticket.component.html` 파일로 이동하여  
    이 단락을 `app-control`로 교체하고  
    닫는 태그도 동일하게 설정하겠습니다.

---

계속 이어가겠습니다.

39. **And now we must import this ControlComponent**  
    **to make it available here.**  
    이제 이 `ControlComponent`를 임포트하여  
    사용 가능하게 만들어야 합니다.

40. **And we also must set this label property.**  
    그리고 이 `label` 속성을 설정해야 합니다.

41. **And since I wanna set it to a string value here,**  
    **I'll not use square brackets**  
    **because I don't need the result**  
    **of some dynamic TypeScript expression here.**  
    문자열 값을 설정할 것이기 때문에  
    대괄호(`[]`)를 사용하지 않겠습니다.  
    동적인 TypeScript 표현식 결과가  
    필요하지 않기 때문입니다.

42. **Instead, I'll just set this to a label of title**  
    **and we can, and should now remove that label here**  
    **because we don't need it anymore.**  
    대신, `label` 속성을 "title"로 설정하고,  
    기존 레이블을 제거하겠습니다.  
    더 이상 필요하지 않기 때문입니다.

43. **I will keep the input though with all its settings.**  
    그러나 입력 필드와 해당 설정은 그대로 유지하겠습니다.

44. **Well, and it's now the same for the text area.**  
    이제 텍스트 영역에도  
    동일한 작업을 수행하겠습니다.

45. **I'll replace this paragraph with app-control**  
    **and set the label property to Request.**  
    이 단락을 `app-control`로 교체하고,  
    `label` 속성을 "Request"로 설정하겠습니다.

46. **Also replace the closing paragraph**  
    **and get rid of that label here, but keep the textarea.**  
    닫는 단락도 교체하고,  
    레이블은 제거하지만 텍스트 영역은 유지하겠습니다.

47. **And with that, if you save that**  
    **and you go back, you'll see the same form as before,**  
    **but it's now rendered with help**  
    **of our custom app ControlComponent,**  
    **as you can see, if you inspect the markup.**  
    이렇게 저장하고 돌아가 보면,  
    이전과 동일한 폼을 확인할 수 있습니다.  
    하지만 이제는 커스텀 `app-ControlComponent`를  
    통해 렌더링됩니다.  
    마크업을 검사하면 이를 확인할 수 있습니다.

48. **And in there we got this paragraph, and then that label**  
    **and that input.**  
    이 안에는 단락과 레이블,  
    그리고 입력 필드가 포함되어 있습니다.

---

**번역이 완료되었습니다.**
