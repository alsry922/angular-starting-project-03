아, 네 이해했습니다. 긴 영어 문장은 줄바꿈하고 한국어 번역을 그 아래에 배치하겠습니다:

1. Now, two other interesting lifecycle hooks that are actually registered differently than the ngOoInit
   and all those other hooks are the afterNextRender and afterRender hooks.

ngOoInit과 다른 모든 훅들과는 다르게 등록되는 두 가지 흥미로운 라이프사이클 훅이 있는데,  
바로 afterNextRender와 afterRender 훅입니다.

2. These are also not available in older versions of Angular.

이전 버전의 Angular에서는 이것들을 사용할 수 없습니다.

3. They have been added with Angular 16.

이들은 Angular 16에서 추가되었습니다.

4. And you do register them with help of the constructor.

그리고 이들은 생성자의 도움을 받아 등록합니다.

5. So not as methods in the component class, but instead with help of the constructor.

따라서 컴포넌트 클래스의 메서드가 아닌, 생성자의 도움을 받아 등록됩니다.

6. Because in that constructor you can then call afterRender, so this afterRender function,
   which is imported from at Angular core or alternatively, afterNextRender,
   which is also imported from at Angular core and to both functions,
   you then pass a function as an argument.

생성자에서 afterRender를 호출할 수 있는데, 이 afterRender 함수는 Angular core에서 임포트되며,  
대안으로 마찬가지로 Angular core에서 임포트되는 afterNextRender도 있으며, 두 함수 모두에 인자로 함수를 전달합니다.

7. And here, our console log afterRender and all console log afterNextRender.

여기서는 console log afterRender와 모든 console log afterNextRender를 사용합니다.

8. Now what's the idea behind these lifecycle hooks here?

자, 이러한 라이프사이클 훅들의 아이디어는 무엇일까요?

9. Well, if you save that and you go back and you reload, you see afterRender and afterNextRender
   are executed here.

저장하고 돌아가서 리로드하면, afterRender와 afterNextRender가 여기서 실행되는 것을 볼 수 있습니다.

10. But you'll also notice that afterRender then is executed again and again basically whenever
    anything changes on that website.

하지만 웹사이트에서 무언가가 변경될 때마다 기본적으로 afterRender가 계속해서 실행되는 것을 알 수 있습니다.

11. So not if something changes in this component, this control component, but anything anywhere
    on this website, anywhere in this Angular app.

이 컴포넌트, 이 제어 컴포넌트에서 뭔가가 변경될 때가 아니라, 이 웹사이트 어디서든,  
이 Angular 앱 어디서든 무언가가 변경될 때입니다.

12. AfterRender is locked over and over again whenever any change occurs, whereas, afterNextRender
    is not locked again.

어떤 변경이 발생할 때마다 afterRender는 계속해서 잠기지만, afterNextRender는 다시 잠기지 않습니다.

13. Because the idea behind these hooks here is that they allow you to define functions that should
    be executed whenever anything changes anywhere in the entire Angular application or after the next change
    anywhere in the entire Angular application.

이러한 훅들의 아이디어는 전체 Angular 애플리케이션 어디서든 무언가가 변경될 때마다,  
또는 전체 Angular 애플리케이션 어디서든 다음 변경 후에 실행되어야 하는 함수들을 정의할 수 있게 해주는 것이기 때문입니다.

14. So it's always the entire application we're talking about here, whereas the other lifecycle hooks
    like ngOoInit ends on refer to the component to which they belong.

따라서 우리가 여기서 이야기하는 것은 항상 전체 애플리케이션이며,  
반면에 ngOoInit과 같은 다른 라이프사이클 훅들은 자신이 속한 컴포넌트를 참조합니다.

15. With afterRender and afterNextRender, it's the entire application instead.

afterRender와 afterNextRender의 경우에는 대신 전체 애플리케이션이 대상입니다.

번역이 완료되었습니다.
