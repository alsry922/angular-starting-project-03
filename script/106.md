1. **Now, ng-content has even more features to offer.**  
   이제 `ng-content`에는 제공할 더 많은 기능이 있습니다.

2. **For example, let's say that we don't want to have**  
   **this icon class on a span outside**  
   **of this button's template here.**  
   예를 들어, 이 버튼 템플릿 외부에서  
   `span`에 `icon` 클래스를 사용하는 것을 원하지 않는다고 가정해봅시다.

3. **So we might prefer to have this span**  
   **with this icon class in our button component's template.**  
   따라서 `icon` 클래스를 가진 `span`을  
   버튼 컴포넌트의 템플릿 안에 포함하는 것이 좋습니다.

4. **And we might wanna wrap that around ng-content.**  
   그리고 이를 `ng-content`로 감쌀 수도 있습니다.

5. **Now of course we could do that**  
   **and still use it in the places where we use the button**  
   **to make this icon here selectable.**  
   물론 이렇게 하면 버튼을 사용하는 곳에서  
   여전히 아이콘을 선택 가능하게 만들 수 있습니다.

6. **But if we do that, we of course end up**  
   **with some duplication.**  
   하지만 그렇게 하면 중복이 발생할 수 있습니다.

7. **If I now inspect the Logout button,**  
   **you see that in there we have that icon span**  
   **which includes another span**  
   **with the class icon inside of it,**  
   **which is an unnecessary duplication.**  
   로그아웃 버튼을 검사해보면,  
   `icon` 클래스가 있는 `span` 안에  
   또 다른 `icon` 클래스를 가진 `span`이 포함된  
   불필요한 중복이 보일 것입니다.

8. **For situations like this, you can offer another feature**  
   **provided by Angular.**  
   이런 상황에서는 Angular에서 제공하는  
   또 다른 기능을 사용할 수 있습니다.

---

계속 이어가겠습니다.

9. **Instead of adding that class here**  
   **in the place where you use the button component,**  
   **you can use the special ngProjectAs attribute,**  
   **which is supported by Angular,**  
   **as you can tell by the prefix.**  
   버튼 컴포넌트를 사용하는 곳에  
   클래스를 추가하는 대신,  
   Angular에서 지원하는 특수 속성인  
   `ngProjectAs`를 사용할 수 있습니다.  
   이는 접두사를 통해 Angular 지원 속성임을 알 수 있습니다.

10. **And you can add it on any element that's used anywhere**  
    **where you're using content projection.**  
    콘텐츠 투영을 사용하는 어디에서든  
    이 속성을 요소에 추가할 수 있습니다.

11. **And it allows you to define a selector**  
    **that can then be matched from inside the component**  
    **where you're trying to project this content into.**  
    이 속성을 사용하면  
    콘텐츠를 투영하려는 컴포넌트 내부에서  
    매칭될 셀렉터를 정의할 수 있습니다.

12. **So here I'm trying to project this icon**  
    **into my button component,**  
    **and I can, for example,**  
    **project this through the icon selector.**  
    여기서 아이콘을 버튼 컴포넌트로 투영하려고 하며,  
    `icon` 셀렉터를 통해 이를 투영할 수 있습니다.

13. **So not the class icon with a dot,**  
    **but the element selector, so to say.**  
    즉, 점(`.`)이 있는 클래스 셀렉터가 아닌,  
    요소 셀렉터를 사용한다는 뜻입니다.

14. **Now I'm not using icon as a HTML element,**  
    **I'm just setting it for the ngProjectAs property here.**  
    `icon`을 HTML 요소로 사용하는 것이 아니라,  
    단순히 `ngProjectAs` 속성으로 설정하는 것입니다.

15. **Now, the effect of that is that in the button component**  
    **where I'm selecting content,**  
    **I can now select content that has the element icon,**  
    **even though I'm never using that element**  
    **because I'm using this ngProjectAs attribute.**  
    그 결과, 버튼 컴포넌트에서 콘텐츠를 선택할 때  
    실제로 `icon` 요소를 사용하지 않더라도  
    `ngProjectAs` 속성을 통해  
    `icon` 요소를 가진 콘텐츠를 선택할 수 있습니다.

---

계속 이어가겠습니다.

16. **So that simply works together with ng-content,**  
    **which therefore allows me to now use**  
    **any selector of my choice.**  
    이렇게 하면 `ng-content`와 함께 작동하며,  
    내가 선택한 모든 셀렉터를 사용할 수 있게 됩니다.

17. **And I can of course now also go to the new-ticket.component.**  
    **And there on this span, instead of using this class here,**  
    **we can also use ngProjectAs and use icon like this.**  
    그리고 이제 `new-ticket.component`로 이동하여,  
    해당 `span`에서 현재 사용 중인 클래스를 대신하여  
    `ngProjectAs`를 사용해  
    `icon`으로 설정할 수 있습니다.

18. **And that will then be picked up by the select property**  
    **on ng-content in the button component.**  
    이렇게 하면 버튼 컴포넌트의  
    `ng-content`에 설정된 `select` 속성에 의해  
    이 요소가 선택됩니다.

19. **And if we save everything, it'll still work as before,**  
    **but now we don't have that unnecessary wrapping.**  
    모든 작업을 저장하면 이전처럼 작동하지만,  
    이제 불필요한 감싸기가 제거됩니다.

20. **We still have a span in a span,**  
    **but we only have one span with the class icon.**  
    여전히 `span` 안에 `span`이 있지만,  
    `icon` 클래스를 가진 `span`은 하나만 남습니다.

21. **And before that we had two spans with that,**  
    **which was unnecessary.**  
    이전에는 `icon` 클래스를 가진 `span`이  
    두 개 있었는데, 이는 불필요한 것이었습니다.

22. **And that's therefore another feature you should be aware of.**  
    그래서 이것은 알고 있어야 할  
    또 다른 Angular 기능입니다.

---

**번역이 완료되었습니다.**
