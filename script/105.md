1. **So now that we worked on this button selector here,**  
   이제 이 버튼 셀렉터를 작업했으니,

2. **I wanna work on its template as well.**  
   템플릿도 함께 작업하고 싶습니다.

3. **Because at the moment, the text logout,**  
   **and this icon is hardcoded into this template.**  
   현재 템플릿에는 "logout" 텍스트와  
   이 아이콘이 하드코딩되어 있습니다.

4. **And that means that whenever we use this component,**  
   **it will be that content that's being output.**  
   이는 이 컴포넌트를 사용할 때마다  
   해당 콘텐츠가 출력된다는 것을 의미합니다.

5. **Now that's fine in the header**  
   **because I copied that content from there.**  
   헤더에서는 문제가 없는데,  
   해당 콘텐츠를 복사해 왔기 때문입니다.

6. **So it is the content I want to have there,**  
   **but if I now were to use my button**  
   **in the new ticket component,**  
   **I'd end up with the wrong markup.**  
   그래서 헤더에서는 적합하지만,  
   `new-ticket` 컴포넌트에서 버튼을 사용하면  
   잘못된 마크업이 나타날 것입니다.

7. **So here in that new ticket component,**  
   **if I temporarily comment out this markup**  
   **so that it's not rendered anymore,**  
   **and I add appButton on this button element**  
   **to use my custom button component here,**  
   **and I then also add my ButtonComponent to the imports,**  
   **that's still required**  
   **to unlock this component in this component template here.**  
   `new-ticket` 컴포넌트에서 마크업을 임시로 주석 처리하여  
   렌더링되지 않도록 하고,  
   이 버튼 요소에 `appButton`을 추가해  
   커스텀 버튼 컴포넌트를 사용하겠습니다.  
   그런 다음, `ButtonComponent`를 임포트에 추가하여  
   템플릿에서 이 컴포넌트를 활성화하겠습니다.

8. **If I do all that, you'll see that if I save that**  
   **and if I reload, we now also have the text logout here,**  
   **and that's, of course, wrong.**  
   이 작업을 모두 수행한 후 저장하고 새로고침하면,  
   여기에도 "logout" 텍스트가 나타나게 되며,  
   이는 당연히 잘못된 것입니다.

9. **So what we need to do here is**  
   **we need to make this button configurable**  
   **or make the template of the button configurable.**  
   따라서 여기서는 버튼이나  
   버튼 템플릿을 구성 가능하게 만들어야 합니다.

---

계속 이어가겠습니다.

10. **And we could do that with help of inputs.**  
    **So with @Input or the input function,**  
    **we could accept one input for the text**  
    **and one input for the icon, for example,**  
    **which technically is also just the text here,**  
    **that would be absolutely fine.**  
    `@Input` 또는 `input` 함수를 사용하여  
    텍스트를 위한 입력값 하나와  
    아이콘(실제로는 텍스트인)을 위한 입력값 하나를  
    받을 수 있습니다.  
    이렇게 해도 전혀 문제가 없습니다.

11. **But here also to show you a different pattern**  
    **and a different Angular feature, I'll not do it like this,**  
    **instead, why don't we use ng-content here?**  
    그러나 여기서는 다른 패턴과 Angular의  
    또 다른 기능을 보여드리기 위해  
    이 방법 대신 `ng-content`를 사용해보겠습니다.

12. **This placeholder, why don't we use that?**  
    **And why don't we also use it here for the icon**  
    **so that we have two placeholders**  
    **for these two different places in our markup.**  
    이 자리 표시자를 사용하고,  
    아이콘에도 동일한 방식을 적용하여  
    마크업에서 두 개의 다른 위치에  
    두 개의 자리 표시자를 사용하는 것은 어떨까요?

13. **If we do it like this,**  
    **we can go back to the header component.**  
    이렇게 하면,  
    헤더 컴포넌트로 돌아가 작업할 수 있습니다.

14. **And now here, between the button tags,**  
    **we could add the logout text and this icon symbol.**  
    이제 버튼 태그 사이에  
    "logout" 텍스트와 아이콘 심볼을 추가할 수 있습니다.

15. **And in the new ticket component,**  
    **I'll comment that back in, remove those spans,**  
    **since it's just the text,**  
    **and the icon I wanna pass into the button,**  
    **and I'll put it like this.**  
    그리고 `new-ticket` 컴포넌트에서는  
    주석 처리를 해제하고,  
    해당 `span`을 제거한 뒤,  
    텍스트와 아이콘을 버튼에 전달하도록 하겠습니다.  
    결과적으로 이렇게 작업할 것입니다.

16. **Well, if we do that and we reload,**  
    **it looks almost right, but it's not entirely right,**  
    **which we can also confirm if we inspect this.**  
    그렇게 하고 새로고침하면,  
    거의 제대로 보이지만 완벽하지 않습니다.  
    이를 검사하면 확인할 수 있습니다.

---

계속 이어가겠습니다.

17. **If we inspect this, we see that now actually, the content,**  
    **so the text and the icon text here,**  
    **was rendered between the second span text here,**  
    **and the first pair of span texts are empty.**  
    검사해보면, 텍스트와 아이콘 텍스트가  
    두 번째 `span` 태그 사이에 렌더링되었으며,  
    첫 번째 `span` 태그는 비어 있는 것을 볼 수 있습니다.

18. **And that makes sense**  
    **because if we're using ng-content multiple times**  
    **in a template,**  
    **Angular, of course, doesn't know**  
    **which content should go where.**  
    이는 합리적입니다.  
    템플릿에서 `ng-content`를 여러 번 사용할 경우,  
    Angular는 콘텐츠가 어디에 들어가야 할지  
    알지 못하기 때문입니다.

19. **So which projected content should go where?**  
    **Therefore we have to tell Angular**  
    **which content should go where.**  
    어느 투영된 콘텐츠가 어디로 가야 하는지  
    Angular에 지시해야 합니다.

20. **And you can tell Angular by adding a special property,**  
    **a special attribute on ng-content, the select attribute.**  
    이를 위해 `ng-content`에 특수 속성인  
    `select` 속성을 추가할 수 있습니다.

21. **Select then wants a CSS selector in the end,**  
    **and it accepts the same kind of selectors**  
    **you could set up on components as selectors,**  
    **and it will then select and output any content**  
    **that matches the selector specified here.**  
    `select`는 최종적으로 CSS 셀렉터를 요구하며,  
    컴포넌트에서 설정할 수 있는  
    동일한 종류의 셀렉터를 지원합니다.  
    그리고 지정된 셀렉터와 일치하는  
    콘텐츠를 선택하고 출력합니다.

22. **So for example, here,**  
    **we could use the class selector icon,**  
    **and remove this span with the class icon from this template**  
    **so that I just have ng-content here,**  
    **and I'm looking for elements with the icon class on them.**  
    예를 들어, 클래스 셀렉터 `icon`을 사용할 수 있으며,  
    이 템플릿에서 `icon` 클래스를 가진 `span`을 제거하고  
    대신 `ng-content`를 사용합니다.  
    이렇게 하면 `icon` 클래스를 가진 요소를 찾게 됩니다.

23. **And now in the place where we use the button.**  
    **So in the header component, for example,**  
    **we can now wrap this icon text with that span**  
    **that has this class.**  
    버튼을 사용하는 곳,  
    예를 들어 `header` 컴포넌트에서  
    아이콘 텍스트를 해당 클래스를 가진  
    `span` 태그로 감쌀 수 있습니다.

---

계속 이어가겠습니다.

24. **And of course, we can do the same**  
    **in the new ticket component.**  
    물론, `new-ticket` 컴포넌트에서도  
    동일한 작업을 수행할 수 있습니다.

25. **Here, I'll wrap this icon with my span like this.**  
    여기서는 아이콘을 이렇게 `span` 태그로 감싸겠습니다.

26. **So with that, between those button tags,**  
    **we have some text which is not wrapped with anything.**  
    **And we have the icon text,**  
    **which is wrapped by a span with class icon.**  
    이렇게 하면 버튼 태그 사이에  
    어떤 태그로도 감싸지 않은 텍스트와,  
    `icon` 클래스를 가진 `span`으로 감싼  
    아이콘 텍스트가 있게 됩니다.

27. **Now, both pieces of content are wrapped**  
    **by the button component,**  
    **and they are therefore projected into that button component.**  
    이제 두 콘텐츠 모두 버튼 컴포넌트에 의해 감싸지며,  
    버튼 컴포넌트로 투영됩니다.

28. **And in the button component template,**  
    **ng-content tells Angular where this wrapped,**  
    **this projected content should be output.**  
    그리고 버튼 컴포넌트 템플릿에서  
    `ng-content`가 Angular에  
    이 투영된 콘텐츠를 출력할 위치를 지시합니다.

29. **But we're actually using multiple ng-contents here,**  
    **and we're therefore using this ng-content**  
    **with the select property set on it**  
    **to select a part of the wrapped content,**  
    **in this case, the part that has the icon class on it,**  
    **so this span here.**  
    하지만 여기서는 여러 `ng-content`를 사용하고 있으므로,  
    `select` 속성을 설정하여  
    감싸진 콘텐츠 중 일부를 선택합니다.  
    여기서는 `icon` 클래스를 가진 `span`을 선택합니다.

30. **And this span will then be output here**  
    **in place of this ng-content.**  
    이 `span`은 `ng-content`가 있는  
    위치에 출력됩니다.

---

계속 이어가겠습니다.

31. **The other ng-content element,**  
    **which does not have any configuration,**  
    **will then output any content**  
    **that's not matched by some other ng-content element.**  
    다른 설정이 없는 나머지 `ng-content` 요소는  
    다른 `ng-content` 요소에 의해 선택되지 않은  
    모든 콘텐츠를 출력합니다.

32. **So that's not selected in any specific way**  
    **by another ng-content element.**  
    즉, 다른 `ng-content` 요소로  
    특정 방식으로 선택되지 않은 콘텐츠입니다.

33. **So with this, if I save everything,**  
    **and I reload, you now see the icon is now properly again,**  
    **and if I inspect my buttons,**  
    **you can also see that it's now that logout text**  
    **that's output between the first span elements,**  
    **and the icon text that's output between the second pair**  
    **of span elements.**  
    이렇게 작업한 후 저장하고 새로고침하면,  
    아이콘이 올바르게 표시되는 것을 확인할 수 있습니다.  
    버튼을 검사해 보면, 첫 번째 `span` 요소 사이에  
    "logout" 텍스트가 출력되고,  
    두 번째 `span` 요소 사이에 아이콘 텍스트가  
    출력되는 것을 확인할 수 있습니다.

34. **And that's how you can use multiple ng-contents**  
    **to select different pieces of wrapped content**  
    **and output them in different places**  
    **of the component template,**  
    **which is another Angular feature**  
    **that can come in handy from time to time.**  
    이렇게 여러 개의 `ng-content`를 사용하여  
    감싸진 콘텐츠의 서로 다른 부분을 선택하고,  
    컴포넌트 템플릿의 다양한 위치에 출력할 수 있습니다.  
    이는 가끔 유용하게 사용할 수 있는  
    또 다른 Angular 기능입니다.

---

**번역이 완료되었습니다.**
