1. Now, when using lifecycle hooks  
   like `ngOnInit`, there is one potential problem.  
   `ngOnInit`과 같은 생명주기 훅을 사용할 때  
   한 가지 잠재적인 문제가 있습니다.

2. It's easy to introduce a typo like here,  
   the lowercase `o`, which is wrong,  
   and you won't get any error  
   because of course you can define methods  
   with any name of your choice in your classes.  
   여기처럼 소문자 `o`와 같은 오타를  
   쉽게 발생시킬 수 있습니다.  
   이는 잘못된 것이지만,  
   클래스에서 원하는 이름으로 메서드를 정의할 수 있으므로  
   오류가 발생하지 않습니다.

3. So defining this method here is not wrong,  
   Angular just won't trigger it  
   which is why if you save that,  
   you might have an error in your application  
   that can be tricky to debug,  
   because you're not getting any error message here  
   and also not here where you ran `npm start`.  
   따라서 이 메서드를 정의하는 것은 잘못된 것이 아니지만,  
   Angular가 이를 실행하지 않기 때문에  
   저장하면 디버깅하기 어려운 애플리케이션 오류가  
   발생할 수 있습니다.  
   이 오류는 코드에서나 `npm start`를 실행한 곳에서  
   오류 메시지가 나타나지 않기 때문입니다.

4. But still, the server status will now never change  
   because the interval was never set up,  
   because this method was never triggered,  
   because you had the typo in here.  
   그러나 오타로 인해 메서드가 실행되지 않았으므로  
   인터벌이 설정되지 않았고,  
   결국 서버 상태는 절대 변경되지 않습니다.

5. To avoid hard-to-debug problems like this,  
   it's recommended to use a specific TypeScript feature  
   that is embraced by Angular  
   when it comes to these lifecycle methods.  
   이러한 디버깅하기 어려운 문제를 방지하려면,  
   생명주기 메서드와 관련하여  
   Angular가 사용하는 특정 TypeScript 기능을  
   사용하는 것이 권장됩니다.

6. You can add the `implements` keyword after your class name,  
   and that's now a keyword  
   that does not exist in vanilla JavaScript.  
   클래스 이름 뒤에 `implements` 키워드를 추가할 수 있습니다.  
   이는 기본 JavaScript에는 없는 키워드입니다.

7. It is a TypeScript feature  
   and it's used to implement an interface,  
   which in the end means that you use an interface,  
   which is another TypeScript feature  
   which we used before to define the shape of an object type,  
   and you can implement interfaces like that in your classes  
   to force your classes to have a certain shape.  
   이는 TypeScript 기능으로, 인터페이스를 구현하는 데 사용됩니다.  
   인터페이스는 객체 타입의 구조를 정의하기 위해  
   이전에 사용했던 TypeScript 기능으로,  
   클래스에서 인터페이스를 구현하여  
   클래스가 특정 구조를 갖도록 강제할 수 있습니다.

8. And Angular exposes an `OnInit` interface,  
   which you can import from `@angular/core`  
   and which you must import from there.  
   Angular는 `OnInit` 인터페이스를 제공하며,  
   이는 `@angular/core`에서 가져와야 합니다.

9. Now, `OnInit` is an interface, as you can tell,  
   and by implementing it into the class,  
   we force ourselves to implement it correctly,  
   which means we need to add all the methods, for example,  
   that are defined on that interface,  
   so that are defined by the Angular team for that interface.  
   `OnInit`은 인터페이스이며,  
   이를 클래스에 구현함으로써  
   인터페이스가 정의한 모든 메서드,  
   예를 들어 Angular 팀이 정의한 메서드를  
   올바르게 구현해야 합니다.

10. And here, I'm now getting an error  
    because I'm not implementing this interface correctly.  
    여기에서는 이 인터페이스를 올바르게 구현하지 않았기 때문에  
    오류가 발생합니다.

11. If I take a look at that error,  
    I see that the property `ngOnInit`  
    is missing in my `ServerStatusComponent` class,  
    and it's required by this `OnInit` interface.  
    이 오류를 살펴보면,  
    `ServerStatusComponent` 클래스에 `ngOnInit` 속성이 없으며,  
    이는 `OnInit` 인터페이스에서 요구된다는 것을 알 수 있습니다.

12. Now of course, I have `ngonInit` in it here  
    but I wrote it incorrectly, I got a typo.  
    물론 여기에는 `ngonInit`이 있지만,  
    잘못 작성되어 오타가 발생한 상태입니다.

13. As soon as I fix that  
    and I have the capital `O` again, this goes away.  
    대문자 `O`로 수정하자마자 오류가 사라집니다.

14. And that's why you should implement those interfaces  
    to protect yourself against unwanted typos like this.  
    그래서 이러한 인터페이스를 구현하여  
    이러한 오타로 인한 문제를 방지해야 합니다.

15. With that, again, if you saved it,  
    everything will work the way it did before  
    and eventually the server status will change,  
    but now with help of `ngOnInit`,  
    implemented with help of this interface.  
    이를 저장하면, 모든 것이 이전과 동일하게 작동하며  
    서버 상태도 변경됩니다.  
    하지만 이번에는 이 인터페이스를 통해 구현된  
    `ngOnInit`을 사용하여 작동합니다.

---

끝났습니다.
