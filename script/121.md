1. Here I am using the constructor  
   of this component class  
   to set up an interval whenever this class is instantiated.  
   여기에서 저는 이 컴포넌트 클래스의 생성자를 사용하여  
   클래스가 인스턴스화될 때마다 인터벌을 설정하고 있습니다.

2. So whenever this component is created in the end.  
   즉, 이 컴포넌트가 생성될 때마다 실행됩니다.

3. Now, you can use the constructor for tasks like this.  
   이러한 작업에 생성자를 사용하는 것은 가능합니다.

4. It's not wrong,  
   but it's typically recommended  
   that you use a different component method  
   because all those Angular Components go  
   through a component lifecycle.  
   이는 틀린 것은 아니지만, 일반적으로는  
   다른 컴포넌트 메서드를 사용하는 것이 권장됩니다.  
   모든 Angular 컴포넌트는 컴포넌트 생명주기를  
   거치기 때문입니다.

5. And that simply means that when Angular instantiates  
   and renders that component  
   and when it then checks it for changes in the future,  
   certain lifecycle hooks are triggered by Angular.  
   이는 Angular가 컴포넌트를 인스턴스화하고 렌더링할 때,  
   그리고 이후 변경 사항을 확인할 때  
   특정 생명주기 훅(lifecycle hook)이  
   Angular에 의해 호출된다는 것을 의미합니다.

6. Certain methods you can add to your component class  
   to run code at certain points in time  
   of this component's lifecycle.  
   컴포넌트 클래스에 특정 메서드를 추가하여  
   컴포넌트 생명주기의 특정 시점에 코드를 실행할 수 있습니다.

7. We already solved the constructor,  
   but therefore example also is an `ngOnInit` method  
   you can add to a component.  
   우리는 이미 생성자를 사용했습니다.  
   하지만 컴포넌트에 추가할 수 있는  
   `ngOnInit` 메서드도 있습니다.

8. Because as you learn in the official docs  
   and a link to this article is attached,  
   this `ngOnInit` method will be executed by Angular  
   whenever Angular has initialized this component's inputs.  
   공식 문서에서 배웠듯이,  
   이 `ngOnInit` 메서드는 Angular가  
   컴포넌트의 입력을 초기화했을 때 실행됩니다.

9. So whenever it essentially is done  
   initializing this component.  
   즉, 이 컴포넌트를 초기화했을 때 실행됩니다.

10. There also are some other hooks,  
    and I'll say right away  
    that you typically don't need all of them.  
    다른 훅도 있지만, 모든 훅이 필요한 것은 아닙니다.

11. Some of them are for pretty niche cases,  
    but I'll get back to them later.  
    일부 훅은 매우 특수한 경우에만 사용되며,  
    이에 대해서는 나중에 다시 설명하겠습니다.

12. For the moment it's this `ngOnInit` hook I'm interested in.  
    현재로서는 이 `ngOnInit` 훅에 관심이 있습니다.

13. To get Angular to execute it, all you have  
    to do is go to your component where you want  
    to do something at that point in the component lifecycle  
    and you add the `ngOnInit` method to that component class.  
    Angular가 이를 실행하도록 하려면,  
    컴포넌트 생명주기의 해당 시점에  
    작업을 수행하려는 컴포넌트로 이동한 후  
    해당 컴포넌트 클래스에 `ngOnInit` 메서드를 추가하면 됩니다.

14. That's all. Now Angular will execute it.  
    그게 전부입니다. 이제 Angular가 이를 실행합니다.

15. It only needs to be there.  
    그 메서드가 존재하기만 하면 됩니다.

16. So now we can grab that code from the constructor  
    and instead execute it in `ngOnInit`.  
    이제 생성자에서 해당 코드를 가져와  
    `ngOnInit`에서 실행할 수 있습니다.

17. Now, even though it did work in the constructor without  
    problems, and even though it wouldn't be wrong  
    for simple use cases  
    and applications like this,  
    you should actually prefer using `ngOnInit`  
    for initialization work like setting up this interval,  
    it is considered a good practice in Angular applications  
    to keep your constructor lean  
    and only do basic class initialization  
    work in there.  
    생성자에서 문제가 없이 작동하더라도,  
    이런 단순한 사용 사례와 애플리케이션에서는 틀린 것은 아니지만,  
    이 인터벌 설정과 같은 초기화 작업은  
    `ngOnInit`을 사용하는 것이 좋습니다.  
    Angular 애플리케이션에서는 생성자를 간결하게 유지하고  
    기본적인 클래스 초기화 작업만 수행하는 것이  
    좋은 관행으로 간주됩니다.

18. So if you wanna assign some initial class property values  
    or things like that.  
    예를 들어, 초기 클래스 속성 값을 할당하는 것과 같은 경우입니다.

19. Anything else, especially more complex tasks  
    like sending HTTP requests,  
    which we'll do later in the course,  
    should not go into the constructor,  
    but instead into `ngOnInit`.  
    그 외의 작업, 특히 HTTP 요청을 보내는 것과 같은  
    더 복잡한 작업은 생성자가 아니라  
    `ngOnInit`에 작성해야 합니다.

20. In addition, as you can also see in the official  
    documentation, one difference between the constructor  
    and `ngOnInit` also is that in `ngOnInit` in it,  
    Angular is done initializing the component inputs.  
    또한, 공식 문서에서도 볼 수 있듯이,  
    생성자와 `ngOnInit`의 또 다른 차이점은  
    `ngOnInit`에서는 Angular가 컴포넌트 입력 초기화를  
    완료한 상태라는 점입니다.

21. So if your component receives any input values,  
    those values will be initialized  
    and will be available in `ngOnInit`,  
    whereas that is not the case in the constructor.  
    따라서 컴포넌트가 입력 값을 받는 경우,  
    해당 값은 초기화되어 `ngOnInit`에서 사용할 수 있지만,  
    생성자에서는 그렇지 않습니다.

22. So that might be another reason for using `ngOnInit`.  
    이것이 `ngOnInit`을 사용하는 또 다른 이유가 될 수 있습니다.

23. But as mentioned in general,  
    you should simply prefer it over the constructor to follow  
    that recommended best practice.  
    하지만 일반적으로, 권장되는 모범 사례를 따르기 위해  
    생성자보다 `ngOnInit`을 선호해야 합니다.

24. With that change made, if you save that, you'll see  
    that if you reload, this application still works the same it  
    did before, eventually the server status will change.  
    이러한 변경을 완료하고 저장하면,  
    새로고침해도 애플리케이션은 이전과 동일하게 작동하며,  
    서버 상태가 결국 변경되는 것을 볼 수 있습니다.

---

끝났습니다.
