1. **So `ngOnDestroy` can be helpful.**  
   `ngOnDestroy`는 유용할 수 있습니다.

2. **Angular actually also has an alternative**  
   **to this `ngOnDestroy` method,**  
   **a more modern alternative**  
   **which won't work in older Angular versions.**  
   Angular에는 `ngOnDestroy` 메서드의 대안이 있으며,  
   이는 더 현대적인 대안이지만  
   이전 Angular 버전에서는 작동하지 않습니다.

3. **So if you are getting problems with the alternative**  
   **I'm about to show you,**  
   **you should simply use `ngOnDestroy`.**  
   제가 곧 보여드릴 대안에서 문제가 발생하면,  
   그냥 `ngOnDestroy`를 사용하면 됩니다.

4. **But here I'll comment out `ngOnDestroy`**  
   **and I'll get rid of that `OnDestroy` interface**  
   **so that I'm not forced to add `ngOnDestroy`.**  
   여기에서는 `ngOnDestroy`를 주석 처리하고,  
   `OnDestroy` 인터페이스를 제거하여  
   `ngOnDestroy`를 강제로 추가하지 않겠습니다.

5. **And I'll get rid of that property, this interval property,**  
   **because now I'll use a different approach**  
   **for cleaning up this interval.**  
   그리고 인터벌 속성을 제거하겠습니다.  
   이제 다른 방법으로 이 인터벌을 정리할 것이기 때문입니다.

6. **Angular allows you**  
   **to inject a special value into your Components.**  
   Angular는 컴포넌트에 특별한 값을  
   주입할 수 있도록 허용합니다.

7. **A so-called `DestroyRef`, a Destroy reference,**  
   **and you can inject it with help of the constructor**  
   **or with help of the `inject` function.**  
   이를 `DestroyRef`(Destroy 참조)라고 하며,  
   생성자 또는 `inject` 함수를 통해 주입할 수 있습니다.

8. **The type you need to inject is `DestroyRef`,**  
   **which is imported from `@angular/core`.**  
   주입해야 할 타입은 `DestroyRef`이며,  
   이는 `@angular/core`에서 가져옵니다.

9. **`DestroyRef` is a class provided by Angular,**  
   **and by injecting it and storing it in a property,**  
   **you can set up a listener with help of that property**  
   **and that injected value that will trigger a function**  
   **whenever the Component into which you injected `DestroyRef`**  
   **is about to be destroyed.**  
   `DestroyRef`는 Angular에서 제공하는 클래스이며,  
   이를 주입하고 속성에 저장하면  
   해당 속성과 주입된 값을 사용하여 리스너를 설정할 수 있습니다.  
   이 리스너는 `DestroyRef`가 주입된 컴포넌트가  
   제거되기 직전에 함수를 실행합니다.

10. **And that's that alternative to `ngOnDestroy` I mentioned.**  
    이것이 제가 언급한 `ngOnDestroy`의 대안입니다.

11. **So here for example,**  
    **we could now simply store our interval in a constant,**  
    **which is only available in `ngOnInit`.**  
    예를 들어, 인터벌을 상수에 저장할 수 있으며,  
    이는 `ngOnInit`에서만 사용 가능합니다.

12. **Because right after setting that interval,**  
    **we can use `DestroyRef` to call `onDestroy`**  
    **and register a function that will be executed**  
    **by Angular when this Component is about to be destroyed.**  
    인터벌을 설정한 직후, `DestroyRef`를 사용하여  
    `onDestroy`를 호출하고,  
    컴포넌트가 제거될 때 Angular가 실행할  
    함수를 등록할 수 있습니다.

13. **And it's now in here where we could call `clearInterval`**  
    **and pass our interval constant to it.**  
    여기에서 `clearInterval`을 호출하고,  
    인터벌 상수를 전달할 수 있습니다.

14. **That interval constant is only available in `ngOnInit`,**  
    **but that's also where I'm setting up this Destroy listener.**  
    인터벌 상수는 `ngOnInit`에서만 사용할 수 있지만,  
    Destroy 리스너도 같은 곳에서 설정됩니다.

15. **And you can use this**  
    **and set up as many `onDestroy` listeners as you need**  
    **in any methods of this Component.**  
    이 방식을 사용하여 필요한 만큼의  
    `onDestroy` 리스너를  
    컴포넌트의 어떤 메서드에서든 설정할 수 있습니다.

16. **You cannot just use it once.**  
    **You can use it as often as you want.**  
    한 번만 사용할 필요는 없습니다.  
    원하는 만큼 사용할 수 있습니다.

17. **And that's therefore an elegant alternative to `ngOnInit`,**  
    **which you also should know about.**  
    이는 `ngOnInit`에 대한 우아한 대안이며,  
    이를 알아두는 것이 좋습니다.

18. **It's not available in older Angular versions,**  
    **but if you are encountering an error related to `DestroyRef`,**  
    **you can simply use `ngOnDestroy` as an alternative.**  
    이전 Angular 버전에서는 사용할 수 없지만,  
    `DestroyRef`와 관련된 오류가 발생한다면  
    `ngOnDestroy`를 대안으로 사용할 수 있습니다.

---

끝났습니다.
