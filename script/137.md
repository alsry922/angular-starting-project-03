So now after lots of important theory,  
이제 많은 중요한 이론을 다뤘으니,

I want to get back to working on that input form here.  
다시 이 입력 폼 작업으로 돌아가고 싶습니다.

And I wanna make sure that we now actually do use the submitted values to create a new ticket.  
그리고 제출된 값을 사용해 실제로 새 티켓을 생성하도록 하고 싶습니다.

And of course, I wanna make sure that we then also show those tickets on the screen eventually.  
물론, 생성된 티켓을 화면에 표시하도록 해야겠죠.

Now, for handling those tickets, we now got different options.  
이제 티켓을 처리하기 위해 몇 가지 방법이 있습니다.

We could use a tickets service, which we use for storing the tickets and for providing those tickets.  
티켓을 저장하고 제공하는 데 사용할 수 있는 `티켓 서비스`를 사용할 수도 있습니다.

But alternatively, we could also manage them in a property of the tickets component  
하지만 대안으로, 티켓 컴포넌트에 속성(property)으로 데이터를 관리하고,

and use a custom event, an output to pass the submitted data from the new ticket component to the tickets component,  
`새 티켓 컴포넌트`에서 제출된 데이터를 사용자 정의 이벤트(output)을 통해 티켓 컴포넌트로 전달한 다음,

and then update that tickets data here in that component whenever new data is submitted.  
새 데이터가 제출될 때마다 해당 컴포넌트에서 티켓 데이터를 업데이트할 수 있습니다.

And that's the approach I'll use here,  
그리고 여기서는 이 방식을 사용할 것입니다.

though you could absolutely also use a service,  
물론 서비스를 사용할 수도 있지만,

but since this section here is about diving deeper into components, I'll use that component focused approach instead of a service.  
이 섹션에서는 컴포넌트를 더 깊이 다루기 때문에 서비스 대신 컴포넌트 중심 접근 방식을 사용할 것입니다.

---

And therefore here, I'll add a tickets property to the tickets component.  
따라서 여기서는 티켓 컴포넌트에 `tickets` 속성을 추가하겠습니다.

And that should hold an array of tickets.  
이 속성은 티켓 배열을 담아야 합니다.

And initially it might be an empty array,  
처음에는 빈 배열일 수 있지만,

but of course I want to define the shape of every ticket.  
물론 각 티켓의 형태를 정의하고 싶습니다.

And therefore I'll add a `ticket.model.ts` TypeScript file,  
그래서 `ticket.model.ts`라는 TypeScript 파일을 추가하겠습니다.

where I will export a ticket interface that describes the shape of such a ticket.  
이 파일에서 해당 티켓의 형태를 설명하는 `ticket` 인터페이스를 내보낼 것입니다.

And here I'll keep it fairly simple.  
그리고 여기서는 형태를 꽤 단순하게 유지하겠습니다.

Every ticket should have an ID, of type string, let's say,  
각 티켓은 `ID`를 가져야 하며, 그 타입은 문자열(string)이라고 가정하겠습니다.

could also be a number, but here I'll go for a string.  
숫자일 수도 있지만 여기서는 문자열을 선택하겠습니다.

It should have a title, which is a string.  
`title` 속성이 필요하며, 이는 문자열입니다.

And then the request text of that ticket, which is a string, and a status.  
그리고 티켓의 요청 텍스트 속성도 문자열이며, `status` 속성도 필요합니다.

And for the status, I want to allow two possible string values.  
`status` 속성에는 두 가지 문자열 값만 허용하고 싶습니다.

I wanna allow `open` and `closed` like this.  
`open`과 `closed` 값을 허용하도록 하겠습니다.

So I have this union type of these two string literal types as they're called.  
그래서 이 두 문자열 리터럴 타입의 유니언 타입을 만들겠습니다.

It's the same approach as before in the server status component,  
이는 이전에 서버 상태 컴포넌트에서 사용했던 접근 방식과 동일합니다.

where we also allowed multiple string values as alternative values,  
그곳에서도 여러 문자열 값을 대체 값으로 허용했으며,

but where we wanted specific string values as allowed values.  
특정 문자열 값만 허용하고자 했습니다.

---

So that's now the ticket model.  
이것이 이제 티켓 모델입니다.

In the tickets component, I then can tell TypeScript that tickets will be an array of such tickets.  
이제 티켓 컴포넌트에서 TypeScript에 `tickets`가 이러한 티켓 배열이라는 것을 지정할 수 있습니다.

So I'm importing tickets from the `ticket.model` file here.  
따라서 여기서 `ticket.model` 파일에서 `tickets`를 가져옵니다.

And I then tell TypeScript that tickets will be an array of such tickets by using this type definition.  
그런 다음 이러한 타입 정의를 사용해 `tickets`가 해당 티켓 배열임을 TypeScript에 알립니다.

You'll always add those square brackets after a type name to tell TypeScript that it'll be an array of that type,  
타입 이름 뒤에 대괄호([])를 추가하면 TypeScript에 해당 타입의 배열임을 알릴 수 있습니다.

an array of objects that have this ticket shape, or an empty array.  
이렇게 티켓 형태를 가진 객체 배열이거나, 빈 배열일 수 있습니다.

That's also fine.  
그것도 가능합니다.

Now of course, we must make sure that we can add tickets to this array.  
이제 당연히, 이 배열에 티켓을 추가할 수 있도록 해야 합니다.

---

번역이 완료되었습니다. 추가 요청이 있다면 알려주세요! 😊
