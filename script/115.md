1. Now when it comes to working  
   with that host element of an Angular component,  
   there are two other things you should know about.  
   Angular 컴포넌트의 호스트 요소를 다룰 때,  
   알아야 할 두 가지 추가 사항이 있습니다.

2. And the first thing is  
   that when it comes to adding properties to the host element,  
   you can use this host setting  
   on the Component decorator object,  
   and that is the preferred way of doing it.  
   첫 번째는, 호스트 요소에 속성을 추가할 때  
   컴포넌트 데코레이터 객체의 `host` 설정을  
   사용하는 것이 가장 권장된다는 점입니다.

3. But alternatively,  
   you can also add a property to your component class  
   and name it className, for example,  
   and set the value you wanna bind on your host element,  
   so control in my case.  
   하지만, 다른 방법으로는 컴포넌트 클래스에 속성을 추가하고  
   예를 들어 `className`으로 이름을 지정한 후  
   호스트 요소에 바인딩할 값을 설정할 수 있습니다.  
   여기에서는 `control` 값을 설정합니다.

4. And then decorate this with the HostBinding decorator,  
   which must be imported from @angular/core.  
   그런 다음, 이를 `@angular/core`에서  
   가져온 `HostBinding` 데코레이터로 장식합니다.

5. Now what HostBinding will do is  
   it will take a look at this property name,  
   and it will then add it as a property  
   to the host element  
   and set this as a value for that property.  
   `HostBinding`은 해당 속성 이름을 확인한 뒤  
   이를 호스트 요소의 속성으로 추가하고,  
   그 값을 설정합니다.

6. Therefore, I can comment out host here  
   and instead use HostBinding.  
   따라서 여기에서 `host`를 주석 처리하고  
   대신 `HostBinding`을 사용할 수 있습니다.

7. Now, I technically don't wanna use className here,  
   but class, and I could use it here.  
   여기에서는 `className` 대신 `class`를 사용하려 합니다.  
   그리고 여기에서 이를 사용할 수 있습니다.

8. But to avoid any confusion with the built-in class keyword,  
   we might wanna use a slightly different property name here.  
   그러나 기본 제공 `class` 키워드와 혼동을 피하기 위해  
   약간 다른 속성 이름을 사용하는 것이 좋습니다.

9. And that's why HostBinding this decorator also  
   takes an optional input, an optional argument,  
   which allows you to define the actual property  
   that should be bound as a string.  
   그래서 `HostBinding` 데코레이터는 선택적으로  
   실제 바인딩할 속성을 문자열로 정의할 수 있는  
   추가 인수를 허용합니다.

10. So now the value here will be set as a value  
    for this class property with help of HostBinding,  
    even though the property name here is different.  
    이제 이 값은 `HostBinding`의 도움으로  
    `class` 속성의 값으로 설정됩니다.  
    속성 이름이 다르더라도 가능합니다.

11. You only need this argument here though  
    if you have a different property name,  
    then you wanna bind.  
    속성 이름이 다르고 이를 바인딩하려는 경우에만  
    이 인수가 필요합니다.

12. With that, if you reload, you got the same look as before,  
    but now with HostBinding.  
    이를 통해 새로고침하면 이전과 같은 모습으로 보이지만,  
    이제는 `HostBinding`을 사용한 상태입니다.

13. That being said, using HostBinding is discouraged though.  
    You should instead use the host property.  
    하지만, `HostBinding` 사용은 권장되지 않습니다.  
    대신 `host` 속성을 사용해야 합니다.

14. This feature just exists for backward compatibility reasons,  
    because in the past it was a common way  
    of setting those host properties.  
    이 기능은 과거에 호스트 속성을 설정하는  
    일반적인 방법이었기 때문에  
    하위 호환성을 위해 존재합니다.

15. Nowadays, you should prefer this host property  
    on the Component decorator object.  
    현재는 컴포넌트 데코레이터 객체에서  
    `host` 속성을 사용하는 것이 더 권장됩니다.

16. There also is a HostListener decorator,  
    which you can import and use,  
    which allows you to bind a method  
    to an event to which you wanna listen here.  
    또한 `HostListener` 데코레이터가 있습니다.  
    이를 가져와 사용하면,  
    특정 이벤트에 메서드를 바인딩할 수 있습니다.

17. Alternatively, you could add event binding here as well.  
    또는, 여기에서 이벤트 바인딩을 추가할 수도 있습니다.

18. And for example, listen to a click event,  
    and then here define the method  
    of the class that should be executed  
    when that event occurs.  
    예를 들어, 클릭 이벤트를 청취하고  
    해당 이벤트가 발생하면 실행될  
    클래스 메서드를 정의할 수 있습니다.

19. So here, for example, we could add an onClick method  
    and simply `console.log('Clicked')`.  
    예를 들어, `onClick` 메서드를 추가하고  
    간단히 `console.log('Clicked')`를 출력할 수 있습니다.

20. And if you wanna trigger this  
    whenever the host element is clicked, we can either do that  
    by adding this value  
    to our host object here in the Component decorator.  
    호스트 요소가 클릭될 때마다 이를 트리거하려면  
    컴포넌트 데코레이터의 호스트 객체에  
    이 값을 추가할 수 있습니다.

21. So I'm using that event binding syntax here,  
    as you can tell.  
    여기에서 이벤트 바인딩 구문을 사용하고 있습니다.

22. And then also as a string,  
    I define the code that should execute  
    when that click on the host element occurs.  
    그리고 문자열로,  
    호스트 요소 클릭 시 실행할 코드를 정의합니다.

23. So here I'm telling Angular  
    that it should execute the onClick method of this component.  
    여기에서 Angular에게 이 컴포넌트의  
    `onClick` 메서드를 실행하라고 알려줍니다.

24. And if you do that  
    and you comment out HostListener for the moment,  
    if you open your console here on the page,  
    whenever I click into one of my controls,  
    you see `Clicked` gets logged here.  
    이를 수행하고 `HostListener`를 주석 처리한 상태에서  
    페이지의 콘솔을 열면,  
    컨트롤을 클릭할 때마다  
    "Clicked"가 기록됩니다.

25. So you can also listen to events on the host element  
    by using this syntax,  
    or as I mentioned, alternatively with HostListener.  
    이 구문을 사용하거나,  
    혹은 앞서 언급한 대로 `HostListener`를 사용하여  
    호스트 요소의 이벤트를 청취할 수 있습니다.

26. Then you would directly assign the method  
    that should be triggered as a value here.  
    그런 다음, 트리거될 메서드를  
    직접 값으로 할당할 수 있습니다.

27. Though, you then also must pass an argument to HostListener  
    and specify the event to which it should listen.  
    하지만, `HostListener`에 인수를 전달하고  
    청취할 이벤트를 지정해야 합니다.

28. So now you would be telling Angular  
    that it should listen to click events on the host element  
    and trigger that method whenever such a click occurs.  
    이제 Angular에게 호스트 요소에서 클릭 이벤트를 청취하고  
    클릭이 발생할 때마다 해당 메서드를 실행하도록  
    지시하게 됩니다.

29. With that, if I save this and reload, we also see  
    that "Clicked" output in the console  
    as I click on those controls.  
    이를 저장하고 새로고침하면,  
    컨트롤을 클릭할 때마다  
    콘솔에서 "Clicked" 출력이 표시됩니다.

30. So that again, is an alternative to using this syntax.  
    이는 이 구문을 사용하는  
    또 다른 대안입니다.

31. Now, I personally actually prefer this alternative.  
    I think it looks a bit cleaner than defining this here,  
    but the Angular team recommends this approach,  
    which is why I'm showing it  
    and recommending it to you here in this course.  
    개인적으로는 이 대안을 선호합니다.  
    이 방식이 여기에서 정의하는 것보다  
    더 깔끔해 보인다고 생각합니다.  
    하지만 Angular 팀에서는 이 방법을 권장하므로  
    강의에서 이를 소개하고 추천합니다.

32. So that's how you could listen  
    to events on your host elements.  
    이렇게 하면 호스트 요소의 이벤트를  
    청취할 수 있습니다.

33. Of course, we now also have to make sure  
    that this onClick method exists though,  
    otherwise this will fail.  
    물론, `onClick` 메서드가 존재하는지도 확인해야 합니다.  
    그렇지 않으면 실행에 실패할 것입니다.

---

끝났습니다.
