1. Now that we covered view child and Content Child,

우리가 view child와 Content Child를 다뤘으니,

2. we can also explore some new lifecycle hooks that are worth mentioning.

언급할 만한 새로운 라이프사이클 훅들을 살펴보겠습니다.

3. Now it's the after view and after content Init lifecycle hooks
   I want to take a closer look at
   before we then also explore after next render and after render.

 after next render와 after render를 살펴보기 전에,
 먼저 after view와 after content Init 라이프사이클 훅들을 자세히 살펴보겠습니다.


4. Because these hooks can be useful
   if you are dealing with elements
   that have been selected with help of view child or content child.

이 훅들은 view child나 content child를 사용해 선택한 요소들을 다룰 때 유용하기 때문입니다.

네, 그럼 계속 진행하겠습니다.

5. And therefore let's start with the after view Init hook.

그러므로 after view Init 훅부터 시작해보겠습니다.

6. To avoid typos, I'll again implement the after view Init interface
   that is provided by Angular and that is imported from at Angular core
   because this interface then forces me to implement the NG after view Init method like this.

오타를 방지하기 위해, Angular에서 제공하고 Angular core에서 임포트되는
after view Init 인터페이스를 다시 구현하겠습니다.
이 인터페이스는 NG after view Init 메서드를 이와 같이 구현하도록 강제하기 때문입니다.

7. You can also omit this colon white thing here though
   that just tells TypeScript that this method doesn't need to return anything.

이 콜론 뒤의 void는 생략할 수 있습니다.
이는 단지 TypeScript에게 이 메서드가 아무것도 반환할 필요가 없다고 알려주는 것입니다.

8. But here I can then log after view Init and what's now the idea behind this hook?

하지만 여기서 after view Init을 로그로 남길 수 있는데, 이 훅의 아이디어는 무엇일까요?

9. Well, in this hook here, you are guaranteed to have access to the elements
   that have been selected with view child,
   unless you of course specified some selector that can't be found.

이 훅에서는 view child로 선택한 요소들에 대한 접근이 보장됩니다.
물론 찾을 수 없는 선택자를 지정한 경우는 제외입니다.

10. But you are guaranteed that the template has been initialized
    and that in theory, Angular therefore is able to select elements in there.

하지만 템플릿이 초기화되었다는 것이 보장되며,
이론적으로 Angular가 그 안의 요소들을 선택할 수 있다는 것이 보장됩니다.

11. So here we can cons log this forum native element and we should get a result.

그래서 여기서 우리는 이 폼의 네이티브 요소를 콘솔에 출력할 수 있고, 결과를 얻을 수 있습니다.

12. On the other hand, if I also implement on Init,
    so this on Init interface, which is also imported from Angular core
    and I therefore add the NG on Init method, which you already saw before earlier,
    I'm not guaranteed that this element exists yet.

반면에, Angular core에서 임포트되는 onInit 인터페이스를 구현하고
이전에 보았던 NGOnInit 메서드를 추가하더라도,
이 시점에서는 해당 요소의 존재가 보장되지 않습니다.

13. So if I log on Init here
    and I try to access the native element here,
    you'll see that if I actually go away from that signal form here,
    back to using that view chart decorator

그래서 여기서 onInit을 로그로 남기고 네이티브 요소에 접근하려고 하면,
signal form에서 벗어나 view chart 데코레이터를 사용할 때,

14. and therefore I'm not executing this,
    but instead I'm accessing the native element like this
    and also like that down here, if I change that code and I save it all,
    you'll see that now if I reload

따라서 이것을 실행하는 대신,
이런 방식으로 네이티브 요소에 접근하고
아래에서도 마찬가지로 접근하면서 코드를 변경하고 저장하면,
페이지를 다시 로드했을 때

15. I got the on Init log here, this one,
    but then I see undefined for that value that I'm trying to get hold of with view child.

여기서 onInit 로그는 얻었지만,
view child로 가져오려고 했던 값은 undefined로 나타납니다.

16. Whereas in after view Init, I do get hold of that element.

반면에 after view Init에서는 그 요소를 확실히 얻을 수 있습니다.

17. That's the difference here.

이것이 바로 여기서의 차이점입니다.

18. Now things are a little bit different if you're using the view child function.

이제 view child 함수를 사용할 때는 상황이 조금 다릅니다.

19. There, you can actually also read it here inside of Init.

거기서는 실제로 Init 내부에서도 읽을 수 있습니다.

20. But when using that decorator there is this important difference
    which you should be aware of because that difference of course means
    that if you're using that decorator for selecting an element and storing it in a property

하지만 데코레이터를 사용할 때는 알아야 할 중요한 차이가 있습니다.
왜냐하면 그 차이는 당연히 데코레이터를 사용해서 요소를 선택하고
속성에 저장할 때 적용되기 때문입니다.

21. and you then wanna do something with that element,
    you can only do so in after view Init or any of your methods
    that are triggered from the template but not inside of NgOnInit

그리고 그 요소로 무언가를 하고 싶다면,
after view Init이나 템플릿에서 트리거되는 메서드에서만 가능하며
NgOnInit 내부에서는 불가능합니다.

22. because there it would still be undefined.

거기서는 여전히 undefined 상태일 것이기 때문입니다.

23. That's something to be aware of and something to keep in mind
    and that's why this lifecycle hook exists.

이것은 알아두어야 할 점이며 명심해야 할 사항입니다.
그래서 이 라이프사이클 훅이 존재하는 것입니다.

24. And that's also why we have this NG after content Init lifecycle hook
    because here in the control component,
    if I implement after content Init, which of course also is imported from at Angular core

그리고 이것이 바로 NG after content Init 라이프사이클 훅이 있는 이유입니다.
컨트롤 컴포넌트에서 Angular core에서 임포트되는
after content Init을 구현한다면,

25. and I therefore then add the NG after content in IT method here,
    I can safely access that content assuming that I got a correct selector here
    inside of NG after content Init

그래서 여기에 NG after content Init 메서드를 추가하면,
올바른 선택자가 있다고 가정할 때
NG after content Init 내부에서 해당 콘텐츠에 안전하게 접근할 수 있습니다.

26. no matter if I'm using the content child function
    or the content child decorator, just as with at view child,
    at content child would not produce a value if I would try to access it inside of on Init

content child 함수를 사용하든 content child 데코레이터를 사용하든 상관없이,
view child와 마찬가지로, content child도 onInit 내부에서 접근하려고 하면
값을 생성하지 않을 것입니다.

27. inside of NG after content Init on the other hand,
    I'm guaranteed to get hold of these values that are selected
    with the content child selector if I did specify a valid selector here, of course.

반면에 NG after content Init 내부에서는,
물론 여기에 유효한 선택자를 지정했다면,
content child 선택자로 선택된 이 값들을 확실히 얻을 수 있습니다.

28. So that's the idea behind NG after content Init and NG after view Init.

이것이 NG after content Init과 NG after view Init의 기본 개념입니다.

번역이 모두 완료되었습니다. 더 도움이 필요하신가요?
