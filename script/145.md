1. So the goal now is to set up our own two-way bindable property in one of our own components.  
   이제 목표는 우리가 만든 컴포넌트 중 하나에 양방향 바인딩 가능한 속성을 설정하는 것입니다.

2. And for that, I created a brand new project, you find it attached.  
   이를 위해 새로운 프로젝트를 생성했으며, 첨부된 프로젝트를 참고하시면 됩니다.

3. And it's a very simple project with a very simple app component  
   이 프로젝트는 매우 간단한 앱 컴포넌트를 포함한 간단한 프로젝트입니다.

4. where I'm outputting some inputs here to allow the user to enter some width and height value.  
   사용자가 너비와 높이 값을 입력할 수 있도록 입력 필드를 출력하고 있습니다.

5. And where I then have one custom component, this `RectComponent`, which outputs a rectangle.  
   그리고 하나의 사용자 정의 컴포넌트인 `RectComponent`를 사용하여 사각형(rectangle)을 출력합니다.

6. And currently, the width and height of that rectangle are set with those dynamic style bindings,  
   현재 이 사각형의 너비와 높이는 동적 스타일 바인딩으로 설정되어 있습니다.

7. but they are set to hardcoded values and that will change over the next minutes.  
   하지만 이 값은 하드코딩된 값으로, 이후 변경될 예정입니다.

8. There also is an `onReset` method here, which currently isn't doing anything.  
   또한 `onReset` 메서드가 있지만, 현재는 아무런 동작도 하지 않습니다.

---

9. Because it's now in this component where I wanna make the size of this rectangle two-way bindable,  
   이제 이 컴포넌트에서 이 사각형의 크기를 양방향 바인딩 가능하게 만들고 싶습니다.

10. so that we can pass new width values into this `RectComponent` from outside it.  
    그래서 외부에서 이 `RectComponent`로 새로운 너비 값을 전달할 수 있도록 합니다.

11. But so that we also get notified about changes here in the app component,  
    또한 앱 컴포넌트에서 변경 사항에 대한 알림을 받을 수 있도록 합니다.

12. so that we can update the values that are shown in those inputs,  
    그렇게 하면 입력 필드에 표시된 값을 업데이트할 수 있습니다.

13. so that the input width and height values are always in sync with the width and height values that are used for the rectangle.  
    입력 필드의 너비와 높이 값이 사각형에 사용되는 너비와 높이 값과 항상 동기화되도록 합니다.

---

### 번역을 문장별로 나눠 제공하고 있습니다. 나머지 문장도 이어서 진행하겠습니다! 😊

14. Now currently, if you run `npm install`  
    현재, `npm install`을 실행하고,

15. and you start this development server with `npm start`,  
    개발 서버를 `npm start`로 시작하면,

16. you'll see a page that looks something like this.  
    대략 이런 페이지를 볼 수 있을 것입니다.

17. And currently changing the width and height here in these inputs  
    그리고 입력 필드에서 너비와 높이를 변경해도,

18. won't have any effect on that rectangle,  
    사각형에는 아무런 영향도 미치지 않습니다.

19. but that's what we'll work on soon.  
    하지만 이것이 우리가 곧 작업할 내용입니다.

20. I also wanna highlight that I am already using two-way binding with `ngModel`  
    여기서 `ngModel`을 사용해 이미 양방향 바인딩을 적용하고 있음을 강조하고 싶습니다.

21. here in the app component.  
    이는 앱 컴포넌트에서 사용됩니다.

22. And here, I'm using it in the way you've seen it many times before.  
    그리고 이는 이전에 여러 번 본 방식으로 사용되고 있습니다.

23. I have some property here,  
    여기서 몇 가지 속성을 가지고 있습니다.

24. here, I'm not using signals, but I could do,  
    여기서는 신호(signal)를 사용하지 않지만, 사용할 수도 있습니다.

25. but here I got an object property with a width and height,  
    하지만 여기서는 너비와 높이 값을 가진 객체 속성을 사용하고 있습니다.

26. and I'm binding the width and height in that object with two-way binding.  
    그리고 객체의 너비와 높이를 양방향 바인딩으로 연결하고 있습니다.

---

27. But of course, this is no custom two-way binding.  
    하지만 물론, 이는 사용자 정의 양방향 바인딩이 아닙니다.

28. Instead, this is two-way binding with `ngModel`,  
    이는 `ngModel`을 사용한 양방향 바인딩입니다.

29. as you've seen it many times before.  
    이전에 여러 번 본 방식으로 사용됩니다.

30. But now we're going to make this `RectComponent` two-way bindable.  
    하지만 이제 `RectComponent`를 양방향 바인딩 가능하도록 만들 것입니다.

31. And specifically there, I wanna accept some size property  
    특히 여기서는 크기(size) 속성을 받아들일 것입니다.

32. that should be two-way bindable.  
    이 속성은 양방향 바인딩 가능해야 합니다.

---

### 나머지 문장도 같은 방식으로 번역을 이어가겠습니다! 😊

33. So let's do that.  
    자, 그 작업을 시작해봅시다.

34. So the goal is to have a `size` property in this `RectComponent`,  
    목표는 이 `RectComponent`에 `size` 속성을 추가하는 것입니다.

35. which should accept values from outside this component.  
    이 속성은 컴포넌트 외부에서 값을 받아들일 수 있어야 합니다.

36. So it should be configurable from outside this component.  
    따라서 컴포넌트 외부에서 설정 가능해야 합니다.

37. And typically, you would do that with the `@Input` decorator  
    일반적으로는 `@Input` 데코레이터를 사용해 설정합니다.

38. or with help of the input function.  
    또는 `input` 함수를 이용할 수도 있습니다.

39. And that is what I'll do here as well.  
    여기서도 같은 방식을 사용할 것입니다.

40. So I'll turn this `size` property into an input.  
    따라서 이 `size` 속성을 입력(`input`)으로 변환하겠습니다.

41. I'll also define its type.  
    그리고 속성의 타입도 정의하겠습니다.

42. And here, I expect to get an object as a value,  
    여기서는 객체 형태의 값을 받을 것으로 예상합니다.

43. which should have a `width`, which should have a value type of `string`,  
    이 객체는 `width`라는 속성을 가지며, 값의 타입은 `string`이어야 합니다.

44. and a `height`, which will also be a `string`.  
    그리고 `height`라는 속성을 가지며, 이 또한 `string` 타입입니다.

45. Since these will be the values that are entered into the input fields.  
    이는 입력 필드에 입력된 값이기 때문입니다.

---

46. Now I also wanna make sure that this is always set.  
    이제 이 속성이 항상 설정되도록 보장하고 싶습니다.

47. So I will set this to be required  
    그래서 이를 필수(required)로 설정하겠습니다.

48. and I'll add this exclamation mark here to make it clear to TypeScript  
    그리고 TypeScript에 명확히 하기 위해 느낌표(`!`)를 추가하겠습니다.

49. that this property will always have a value,  
    이 속성은 항상 값을 가진다는 것을요.

50. even though we don't assign an initial value here.  
    초기 값을 여기에서 할당하지 않더라도 말입니다.

51. So that is the `size` I expect to get.  
    이것이 제가 기대하는 `size` 속성입니다.

52. And of course, with that `size` set from outside,  
    물론, 외부에서 설정된 `size`를 사용하여,

53. we can go to the template of this component  
    이 컴포넌트의 템플릿으로 이동해,

54. and now set the width and height here on this `div` dynamically.  
    여기 `div`에 너비와 높이를 동적으로 설정할 수 있습니다.

---

### 나머지도 동일한 형식으로 계속 번역하겠습니다! 😊

55. By accessing `size.width` here and combining that with `px` to get a pixel value,  
    여기서 `size.width`를 접근하고 `px`를 결합하여 픽셀 값을 얻습니다.

56. and then here, I'll have `size.height`.  
    그리고 여기서는 `size.height`를 사용합니다.

57. That should set the width and height.  
    이렇게 하면 너비와 높이를 설정할 수 있습니다.

58. Of course, we now must make sure that in the app component  
    물론, 이제 앱 컴포넌트에서

59. we do bind that `size` property.  
    `size` 속성을 바인딩해야 합니다.

60. And for that, we wanna pass this `rectSize` property here  
    이를 위해 여기서 `rectSize` 속성을

61. as a value for this `size` property to `app-rect`.  
    `app-rect`의 `size` 속성 값으로 전달합니다.

62. If you do all that and you save that,  
    이렇게 모든 작업을 완료하고 저장하면,

63. you should have an application  
    애플리케이션이 생성되며,

64. where now this cube here is in the end kind of connected to the app component.  
    이제 이 사각형은 앱 컴포넌트와 연결된 상태가 됩니다.

65. And if I change the width here, for example,  
    예를 들어, 여기서 너비를 변경하면,

66. you see that now the dimensions of this rectangle change with it.  
    사각형의 크기가 변경된 것을 확인할 수 있습니다.

---

67. So that's good. We got one-way binding now.  
    이것은 좋습니다. 현재 우리는 단방향 바인딩을 구현했습니다.

68. We're updating the dimensions of this rectangle with help of this input.  
    이 입력 필드를 통해 사각형의 크기를 업데이트하고 있습니다.

69. But now I also wanna make sure  
    하지만 이제 제가 원하는 것은,

70. that when we click this rectangle,  
    이 사각형을 클릭했을 때

71. we trigger this `onReset` method here  
    여기 있는 `onReset` 메서드를 호출하고,

72. and in there, I wanna reset this rectangle to some fixed dimensions.  
    그 메서드에서 사각형의 크기를 고정된 값으로 재설정하고자 합니다.

73. So I wanna change `this.size` and set it to some new dimensions.  
    즉, `this.size` 값을 변경하여 새로운 크기로 설정하려고 합니다.

---

### 나머지 번역도 이어서 진행하겠습니다! 😊

74. But this is not how we should do it,  
    하지만 이렇게 하는 것은 적절하지 않습니다.

75. because `size` is just an input.  
    `size`는 단순히 입력 속성(input)이기 때문입니다.

76. It's not meant to communicate back to the component that passed the input value.  
    입력 값을 전달한 컴포넌트로 값을 다시 전달하기 위해 설계된 것이 아닙니다.

77. Instead, for that, we need that two-way binding I'm talking about.  
    이를 위해 양방향 바인딩이 필요합니다.

78. And to set this up with decorators,  
    이를 데코레이터를 사용해 설정하려면,

79. so with the `@Input` decorator being used,  
    `@Input` 데코레이터를 사용하는 것처럼,

80. we have to add a second property to this `RectComponent`  
    이 `RectComponent`에 두 번째 속성을 추가해야 합니다.

81. and decorate that with the `@Output` decorator.  
    그리고 해당 속성을 `@Output` 데코레이터로 장식해야 합니다.

82. Because two-way binding in the end is the combination of input and output.  
    왜냐하면 양방향 바인딩은 결국 입력과 출력의 결합이기 때문입니다.

83. We're accepting a value, but we're also updating a value.  
    값을 받아들이는 동시에 값을 업데이트합니다.

84. So we need an output as well as an input.  
    따라서 입력뿐만 아니라 출력도 필요합니다.

---

85. And now what's important is that this output must have a very specific name  
    그리고 중요한 점은, 이 출력 속성은 특정한 이름을 가져야 한다는 것입니다.

86. for Angular to understand that you want to have a two-way bindable property.  
    Angular가 이 속성이 양방향 바인딩 가능 속성임을 이해할 수 있도록 하기 위해서입니다.

87. Because you now must use the same property name as you used for the input,  
    입력 속성에 사용했던 것과 동일한 이름을 사용해야 합니다.

88. but then add `Change` at the end of it.  
    다만, 이름 끝에 `Change`를 추가해야 합니다.

89. And this is now not up to you.  
    이는 선택 사항이 아닙니다.

90. This output must be named like this  
    출력 속성은 반드시 이런 방식으로 이름을 지정해야 합니다.

91. for Angular to understand that this input and output belong together  
    그래야 Angular가 이 입력과 출력이 연결된 것임을 이해하고,

92. and together create a two-way bindable `size` property.  
    이를 통해 양방향 바인딩 가능한 `size` 속성을 생성할 수 있습니다.

---

93. Then you still create an `EventEmitter` here  
    그런 다음, 여기서 `EventEmitter`를 생성합니다.

94. and you define the data that will be emitted.  
    그리고 방출될 데이터의 형식을 정의합니다.

95. And here, I plan on emitting an object  
    여기서는 객체를 방출할 계획입니다.

96. that has exactly the same shape as the input,  
    이 객체는 입력과 동일한 구조를 가집니다.

97. because this output is meant to change that input value  
    왜냐하면 이 출력은 입력 값을 변경하기 위해 설계되었기 때문입니다.

98. in the component that created that value and passed it into this component.  
    입력 값을 생성하고 이 컴포넌트로 전달한 컴포넌트에서 값을 변경하기 위해서입니다.

---

### 이어서 계속 진행하겠습니다! 😊

99. So in the app component in our case.  
    즉, 우리 사례에서는 앱 컴포넌트에서 값을 변경하게 됩니다.

100. And therefore then here in `onReset`,  
     따라서 여기 `onReset` 메서드에서,

101. we now must call `this.sizeChange.emit`.  
     이제 `this.sizeChange.emit`을 호출해야 합니다.

102. And now emit this new object  
     그리고 새로운 객체를 방출해야 합니다.

103. that should replace the old input value in the component that created it.  
     이는 입력 값을 생성한 컴포넌트에서 기존 값을 대체할 것입니다.

104. So in the app component eventually.  
     결국 앱 컴포넌트에서 그렇게 될 것입니다.

105. And therefore here, I'll emit an object  
     따라서 여기서 객체를 방출하겠습니다.

106. where `width` is set to, let's say, `200`,  
     여기서 `width`는 `200`으로 설정하고,

107. if that is the value we want to reset it to,  
     우리가 재설정하려는 값이 `200`이라면요.

108. and `height` is set to `100`, both as strings.  
     그리고 `height`는 `100`으로 설정하며, 두 값 모두 문자열로 지정합니다.

---

109. And now with this very specific syntax,  
     이제 이 특정 구문을 통해,

110. with this combination of input and output,  
     입력과 출력의 조합으로,

111. we created a two-way bindable `size` property.  
     양방향 바인딩 가능한 `size` 속성을 생성했습니다.

112. And therefore back in the app component template,  
     따라서 앱 컴포넌트 템플릿으로 돌아가서,

113. we can now use the two-way binding syntax on `size`,  
     이제 `size` 속성에 양방향 바인딩 구문을 사용할 수 있습니다.

114. just as we also used it on `ngModel` before.  
     이전에 `ngModel`에서 사용했던 방식과 동일하게요.

115. Now we can use it on our own property and our own component.  
     이제 우리만의 속성과 컴포넌트에서도 이를 사용할 수 있습니다.

---

116. And we don't need to change anything else here in this app component template  
     그리고 이 앱 컴포넌트 템플릿에서는 다른 것을 변경할 필요가 없습니다.

117. and also not in the app component TypeScript file.  
     앱 컴포넌트의 TypeScript 파일에서도 마찬가지입니다.

118. Instead, Angular will do all the heavy lifting for us.  
     대신 Angular가 모든 작업을 처리해줄 것입니다.

119. And therefore with that, if I now save that  
     따라서 이를 저장한 후,

120. and I go back, I can still change these input values,  
     돌아가서 입력 값을 변경하면,

121. and you see that this rectangle adjusts.  
     사각형 크기가 조정되는 것을 확인할 수 있습니다.

122. But we can now also click this rectangle,  
     이제 이 사각형을 클릭하면,

123. and that will then pass data back to the app component,  
     앱 컴포넌트로 데이터를 다시 전달하게 됩니다.

124. which is reflected here in these input fields  
     이는 입력 필드에 반영되며,

125. and which updates the rectangle.  
     사각형도 업데이트됩니다.

---

126. And that is how you can set up custom two-way binding.  
     이것이 사용자 정의 양방향 바인딩을 설정하는 방법입니다.

127. By combining inputs and outputs  
     입력과 출력을 결합하고,

128. and by making sure that you follow this very specific naming pattern.  
     이 특정한 이름 규칙을 따르는 방식으로 말입니다.

---

번역이 완료되었습니다! 문장을 적절히 끊어, 쉽게 이해할 수 있도록 구성했습니다. 추가 요청이 있다면 언제든 말씀해주세요! 😊
