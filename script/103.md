1. **So, we got this button here,**  
   여기 버튼이 있습니다.

2. **and we, in the end, got the same kind of button**  
   **in the header component.**  
   그리고 최종적으로, 헤더 컴포넌트에서도  
   같은 종류의 버튼을 사용하고 있습니다.

3. **It's essentially the same markup,**  
   **just some different text and a different icon.**  
   기본적으로 마크업은 동일하며,  
   텍스트와 아이콘만 다릅니다.

4. **Therefore, we could strongly consider**  
   **creating a reusable component,**  
   **and that's what I'll do.**  
   따라서 재사용 가능한 컴포넌트를  
   만드는 것을 적극 고려할 수 있으며,  
   저는 그렇게 하려고 합니다.

5. **I'll generate a new component,**  
   **and I'll generate it in a shared folder,**  
   **which doesn't exist yet,**  
   **because my button does not just belong to the dashboard.**  
   새로운 컴포넌트를 생성하고,  
   아직 존재하지 않는 `shared` 폴더에 추가할 것입니다.  
   이 버튼은 대시보드에만 속하지 않기 때문입니다.

6. **Instead, it's a shared Component**  
   **that could be used anywhere in the application.**  
   대신, 애플리케이션 어디서나  
   사용할 수 있는 공유 컴포넌트입니다.

7. **And I prefer to store such shared Components**  
   **in a folder named shared,**  
   **though that's just a personal preference**  
   **and not something you have to follow.**  
   저는 이러한 공유 컴포넌트를  
   `shared`라는 폴더에 저장하는 것을 선호합니다.  
   이는 개인적인 선호일 뿐이며,  
   반드시 따라야 하는 규칙은 아닙니다.

8. **But here I'll go for the shared folder**  
   **and then in there add a button, a button component,**  
   **and I'll skip the test files as always.**  
   하지만 여기서는 `shared` 폴더를 사용하고,  
   버튼 컴포넌트를 추가할 것입니다.  
   테스트 파일은 항상 그렇듯 생략하겠습니다.

9. **Now, this generates me a new shared folder**  
   **with that button component,**  
   **and we can now go to the header component, for example,**  
   **and grab that button markup**  
   **and bring that over into that button component.**  
   이제 새로 생성된 `shared` 폴더 안에  
   버튼 컴포넌트가 추가됩니다.  
   그런 다음, 예를 들어, 헤더 컴포넌트로 이동해  
   버튼 마크업을 가져와  
   버튼 컴포넌트로 옮길 수 있습니다.

10. **Or at least that is something we could do.**  
    **But now here's a new pattern**  
    **which you haven't seen before**  
    **when it comes to creating Components.**  
    또는 최소한 그렇게 할 수 있습니다.  
    하지만 이제 컴포넌트를 생성할 때  
    이전에 보지 못한 새로운 패턴을 소개하겠습니다.

---

계속 이어가겠습니다.

11. **Because what would happen**  
    **if we would set up this button like this?**  
    우리가 이 버튼을 이런 방식으로 설정하면  
    어떻게 될까요?

12. **Well, we would end up with a custom app button component,**  
    **this selector here,**  
    **and we could use that anywhere where we want such a button.**  
    우리는 `app-button`이라는 커스텀 컴포넌트를  
    가지게 될 것이며,  
    이 버튼이 필요한 어디에서든 사용할 수 있습니다.

13. **Now, let's do this real quick**  
    **to see what that gives us in the DOM.**  
    이제 이를 빠르게 설정해보고,  
    DOM에서 어떤 결과를 주는지 확인해 보겠습니다.

14. **So I'll go to that header component,**  
    **and I'll replace that button here**  
    **with my app button like this,**  
    **and I'll then import this app button here**  
    **to make it available in the header component.**  
    헤더 컴포넌트로 이동해  
    버튼을 `app-button`으로 교체하겠습니다.  
    그런 다음 `app-button`을 임포트하여  
    헤더 컴포넌트에서 사용할 수 있도록 하겠습니다.

15. **Now, since I just copy and pasted the markup**  
    **that was previously the header,**  
    **this button will still look the way it did before.**  
    이전에 헤더에서 사용했던 마크업을  
    복사하여 붙여넣었기 때문에,  
    버튼은 이전과 동일하게 보일 것입니다.

16. **So if we now save that and reload, of course,**  
    **the UI looks as it did before.**  
    이를 저장하고 새로고침하면,  
    UI는 이전과 동일하게 보일 것입니다.

17. **But let's now inspect that button here with the Dev tools.**  
    하지만 이제 DevTools를 사용해  
    버튼을 검사해 보겠습니다.

18. **If we do that, we can see that button element here,**  
    **but we can also see something else that's interesting,**  
    **the app button element.**  
    그렇게 하면 버튼 요소뿐만 아니라,  
    `app-button` 요소도 볼 수 있습니다.

19. **So, our component element is also here,**  
    **and that's really important to understand in Angular.**  
    즉, 컴포넌트 요소도 DOM에 있으며,  
    이는 Angular에서 중요한 개념입니다.

---

계속 이어가겠습니다.

20. **Your component elements do end up in the real DOM.**  
    **You can see them everywhere,**  
    **app header, app button, and so on.**  
    컴포넌트 요소는 실제 DOM에 포함됩니다.  
    이를 어디서든 볼 수 있습니다.  
    예를 들어, `app-header`, `app-button` 등이 있습니다.

21. **And in the main section you'd find the app dashboard item**  
    **and so on.**  
    메인 섹션에서는 `app-dashboard-item` 등을  
    확인할 수 있습니다.

22. **So your component elements are not compiled away**  
    **or replaced with the template content by Angular.**  
    컴포넌트 요소는 Angular에 의해  
    컴파일되거나 템플릿 내용으로 대체되지 않습니다.

23. **Instead, they are rendered to the DOM,**  
    **and the template content is then nested inside of them.**  
    대신, 이들은 DOM에 렌더링되며,  
    템플릿 내용은 해당 요소 내부에 중첩됩니다.

24. **Now, that's no problem or anything like that,**  
    **but it means that we sometimes have some redundant,**  
    **unnecessary element in the DOM,**  
    **like here with the app button.**  
    이것은 문제가 되지는 않지만,  
    DOM에 중복되거나 불필요한 요소가 생길 수 있다는 뜻입니다.  
    예를 들어, 여기 `app-button`처럼요.

25. **It's, in the end, some unnecessary duplication,**  
    **which we have here,**  
    **having a wrapper that's almost named button**  
    **around an element that's named button.**  
    결국, 버튼이라는 요소를 감싸고 있는  
    또 다른 버튼과 같은 이름의 래퍼를  
    가지는 중복이 발생한 것입니다.

26. **Sure, we can do that.**  
    **As you see, we get the intended result.**  
    물론, 이렇게 해도 됩니다.  
    보시다시피, 원하는 결과는 얻을 수 있습니다.

27. **It looks good.**  
    **But we can actually change our code here**  
    **to end up with a leaner DOM.**  
    보기에는 좋지만,  
    코드를 변경하여 DOM을 더 간결하게 만들 수 있습니다.

---

계속 이어가겠습니다.

28. **Because what we essentially wanna do here**  
    **with that button component is**  
    **that we wanna kind of extend the built-in button component.**  
    여기서 우리는 기본 버튼 컴포넌트를 확장하려고 합니다.

29. **I want to keep all its capabilities.**  
    **I want to be able to listen**  
    **to all its events if needed and so on,**  
    **but I want to extend it**  
    **because I want to have more control**  
    **over its markup in this case.**  
    기본 버튼의 모든 기능을 유지하면서,  
    필요할 때 이벤트를 수신할 수 있어야 하며,  
    마크업에 대한 제어권을 더 많이 가지기 위해  
    이를 확장하려는 것입니다.

30. **And if you have a situation like this**  
    **where you essentially want to extend a built-in component,**  
    **you can follow a slightly different approach to building it.**  
    기본 컴포넌트를 확장하고자 할 때는  
    약간 다른 방식으로 컴포넌트를 생성할 수 있습니다.

---

**번역이 완료되었습니다.**
