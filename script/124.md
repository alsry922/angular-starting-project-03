1. So now that we had a thorough first look  
   at all these lifecycle hooks  
   and these methods you can add to your Angular components,  
   we'll move back to the main project.  
   이제 Angular 컴포넌트에 추가할 수 있는  
   생명주기 훅과 메서드를 처음부터 자세히 살펴보았으니,  
   메인 프로젝트로 돌아가겠습니다.

2. Though you'll see some of these hooks in action  
   throughout this course, and also later in this section.  
   이 강의 전체와 섹션 후반부에서  
   이러한 훅들이 실제로 어떻게 작동하는지  
   확인할 수 있을 것입니다.

3. I'll also get back to `afterNextRender`  
   and `afterRender` later.  
   `afterNextRender`와 `afterRender`에 대해서도  
   나중에 다루겠습니다.

4. But one hook I actually want to add  
   to our main project right away, right now  
   is the `ngOnDestroy` hook  
   because we got a use case for that in our project.  
   하지만 지금 바로 메인 프로젝트에 추가하고 싶은 훅은  
   `ngOnDestroy`입니다.  
   프로젝트에서 이 훅이 필요한 경우가 있기 때문입니다.

5. Now to make sure I don't have any typos,  
   I'll implement `OnInit` and `OnDestroy`,  
   separated by a comma,  
   and `OnDestroy` must be imported from `@angular/core`.  
   오타가 없도록 하기 위해,  
   `OnInit`과 `OnDestroy`를 쉼표로 구분하여 구현하겠습니다.  
   그리고 `OnDestroy`는 `@angular/core`에서  
   가져와야 합니다.

6. And with it imported,  
   I then have to add the `ngOnDestroy` method here.  
   이를 가져온 후,  
   `ngOnDestroy` 메서드를 추가해야 합니다.

7. By the way, the order of the methods does not matter.  
   메서드의 순서는 중요하지 않습니다.

8. The order is up to you.  
   순서는 여러분이 결정하면 됩니다.

9. But now, here, in `ngOnDestroy`,  
   we can do cleanup work.  
   `ngOnDestroy`에서는 정리 작업을 수행할 수 있습니다.

10. We might want to perform  
    right before the component is gone, so to say.  
    즉, 컴포넌트가 제거되기 직전에  
    수행해야 할 작업을 처리할 수 있습니다.

11. Now here in my application,  
    this component is actually never gone.  
    현재 제 애플리케이션에서는  
    이 컴포넌트가 실제로 제거되지 않습니다.

12. We can't switch to other pages  
    and we're not rendering it conditionally.  
    다른 페이지로 이동할 수도 없고,  
    조건부로 렌더링되지도 않습니다.

13. So it's always there.  
    따라서 항상 존재합니다.

14. But for some components, that might be different.  
    하지만 일부 컴포넌트는 다를 수 있습니다.

15. And since I'm setting up an interval here,  
    and we might, in the future,  
    use this component such that it may disappear,  
    it is a good idea to clean up  
    that interval whenever that component is removed.  
    현재 이 컴포넌트에서 인터벌(interval)을 설정하고 있으며,  
    나중에 이 컴포넌트가 제거될 가능성이 있기 때문에  
    컴포넌트가 제거될 때마다  
    해당 인터벌을 정리하는 것이 좋습니다.

16. Because even though if that's not the case yet here  
    in this application,  
    that might change in the future.  
    현재 애플리케이션에서는 해당되지 않더라도  
    나중에 변경될 가능성이 있습니다.

17. And if you have an interval  
    that keeps on going behind the scenes  
    even though the component is gone,  
    you have a memory leak in your application,  
    and you can have a negative impact on the performance  
    of your application,  
    which no one wants, of course.  
    컴포넌트가 제거되었음에도  
    백그라운드에서 계속 실행되는 인터벌이 있다면,  
    애플리케이션에 메모리 누수가 발생하게 되고,  
    성능에 부정적인 영향을 미칠 수 있습니다.  
    이는 당연히 피해야 합니다.

18. That's why we should clean up our interval here  
    with `ngOnDestroy`.  
    따라서 `ngOnDestroy`를 사용하여  
    인터벌을 정리해야 합니다.

19. **Now how can we do that?**  
    이제 이를 어떻게 할 수 있을까요?

20. **Well, `setInterval` returns a value of type `NodeJS.Timeout`,**  
    **which is basically an ID of the interval that's created here.**  
    `setInterval`은 `NodeJS.Timeout` 타입의 값을 반환합니다.  
    이는 기본적으로 생성된 인터벌의 ID입니다.

21. **So we can add a new private property,**  
    **private since we don't need it in the template,**  
    **and name it `interval`.**  
    따라서 템플릿에서 필요하지 않으므로  
    새 private 속성을 추가하고 이름을 `interval`로 지정합니다.

22. **And the type should be `NodeJS.Timeout`, or `undefined`,**  
    **so I'll add this question mark here.**  
    타입은 `NodeJS.Timeout` 또는 `undefined`로 설정해야 하므로  
    물음표를 추가합니다.

23. **And then we should set this `interval` here**  
    **to the result of calling `setInterval`.**  
    그런 다음 `setInterval` 호출 결과를  
    `interval`에 설정해야 합니다.

24. **Now we can use it in `ngOnDestroy` to remove it**  
    **with help of the `clearTimeout` method.**  
    이제 `ngOnDestroy`에서  
    `clearTimeout` 메서드를 사용하여 이를 제거할 수 있습니다.

25. **To that, we can pass this `interval`.**  
    그리고 여기에 `interval`을 전달하면 됩니다.

26. **So this ID, which we stored in this `interval` property.**  
    이는 `interval` 속성에 저장된 ID입니다.

27. **And with that, we're making sure**  
    **that this interval gets cleaned up**  
    **when the component is removed.**  
    이를 통해 컴포넌트가 제거될 때  
    해당 인터벌이 정리되도록 보장합니다.

28. **Again, this component is never removed.**  
    다시 말하지만, 이 컴포넌트는 제거되지 않습니다.

29. **Nonetheless, that is something you typically want to do**  
    **to avoid potential memory leaks.**  
    그럼에도 잠재적인 메모리 누수를 방지하기 위해  
    일반적으로 수행해야 하는 작업입니다.

30. **Now you might be getting an error here**  
    **regarding this `NodeJS.Timeout` thing.**  
    여기에서 `NodeJS.Timeout`과 관련된  
    오류가 발생할 수 있습니다.

31. **And if that's the case,**  
    **you can replace this type with `ReturnType`,**  
    **which is a special type provided by TypeScript.**  
    그런 경우, TypeScript에서 제공하는 특수 타입인  
    `ReturnType`으로 이를 대체할 수 있습니다.

32. **`ReturnType` is a bit more advanced TypeScript code,**  
    **and it's all TypeScript code, it has nothing to do with Angular.**  
    `ReturnType`은 조금 더 고급 TypeScript 코드이며,  
    이는 Angular와는 무관한 TypeScript 코드입니다.

33. **It simply means that the type of `interval`**  
    **should be the type of value returned by `setInterval`.**  
    이는 단순히 `interval`의 타입이  
    `setInterval`에서 반환된 값의 타입이어야 한다는 것을 의미합니다.

34. **And with that, this error should go away,**  
    **and the application should work as before.**  
    이를 통해 오류가 사라지고,  
    애플리케이션은 이전처럼 정상 작동할 것입니다.

35. **But now, the interval is theoretically removed**  
    **when that component is removed from the screen.**  
    하지만 이제 이론적으로는 컴포넌트가  
    화면에서 제거될 때 인터벌도 제거됩니다.

---

끝났습니다.
