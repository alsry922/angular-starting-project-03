1. Now this host property,  
   which can be added to @Component,  
   can be useful as I explained, because we can, for example,  
   also use it somewhere else in our application,  
   on the dashboard item.  
   `@Component`에 추가할 수 있는 이 `host` 속성은  
   제가 설명한 것처럼 유용할 수 있습니다.  
   예를 들어, 애플리케이션의 다른 곳,  
   대시보드 항목에서도 사용할 수 있습니다.

2. In the dashboard item template,  
   I have that div with the class dashboard item.  
   대시보드 항목 템플릿에는  
   `dashboard-item` 클래스가 있는 div가 있습니다.

3. And this is a bit redundant.  
   We don't need that extra wrapper around this article.  
   하지만 이것은 다소 중복적입니다.  
   이 article 주위에 불필요한 래퍼가 필요하지 않습니다.

4. So what we could do is remove it here from our template  
   and we could now go to the dashboard item component  
   TypeScript file and add host here.  
   그래서 템플릿에서 이를 제거하고,  
   대시보드 항목 컴포넌트 TypeScript 파일로 이동하여  
   `host`를 추가할 수 있습니다.

5. And then again, use that setting to add the class property  
   to the host element, so to this app-dashboard-item element,  
   and set it to a value of dashboard-item,  
   or whichever CSS class you want to add here.  
   그런 다음, 해당 설정을 사용하여 호스트 요소,  
   즉 `app-dashboard-item` 요소에 클래스 속성을 추가하고,  
   이를 `dashboard-item` 또는 원하는 CSS 클래스로 설정합니다.

6. And if you do that,  
   you'll see that your application looks broken.  
   그렇게 하면 애플리케이션이  
   깨져 보이는 것을 알 수 있습니다.

7. Well, it is now broken  
   because of course in the dashboard item CSS file,  
   I'm still setting up styles  
   that are scoped to this component  
   so that only look for matches  
   inside of the component template.  
   이는 대시보드 항목 CSS 파일에서 여전히  
   이 컴포넌트에 한정된 스타일을 설정하고 있어  
   컴포넌트 템플릿 내부에서만  
   일치하는 요소를 찾기 때문입니다.

8. So if I'm looking for an element with a CSS class  
   of dashboard-item on it, Angular will only look for it  
   in this component's template.  
   따라서 `dashboard-item` CSS 클래스를 가진 요소를 찾으면  
   Angular는 이 컴포넌트 템플릿 내부에서만 이를 찾습니다.

9. And here we have no such element  
   with that class on it anymore.  
   그리고 여기에는 더 이상  
   해당 클래스를 가진 요소가 없습니다.

10. Sure, that class exists on the host element  
    and you can confirm that it was added  
    by inspecting this on the running page.  
    물론, 해당 클래스는 호스트 요소에 존재하며,  
    실행 중인 페이지에서 이를 검사하여  
    추가되었음을 확인할 수 있습니다.

11. Here on app-dashboard-item, you find that class,  
    but it is ignored because of that style scoping,  
    because of that encapsulation.  
    `app-dashboard-item`에서 해당 클래스를 찾을 수 있지만,  
    스타일 범위 지정과 캡슐화로 인해 무시됩니다.

12. So of course we could disable encapsulation  
    by setting encapsulation to view encapsulation none,  
    as we did it for a control component,  
    or we go for a different approach,  
    which is what I'll do here.  
    따라서 캡슐화를 비활성화하고  
    `ViewEncapsulation.None`으로 설정할 수도 있지만,  
    여기에서는 다른 방법을 사용할 것입니다.

13. Nonetheless, I wanted to highlight that you can add  
    that host property to any component,  
    not just components without view encapsulation.  
    하지만, `host` 속성은 캡슐화가 없는 컴포넌트뿐만 아니라  
    모든 컴포넌트에 추가할 수 있다는 점을 강조하고 싶습니다.

14. Here for this specific use case,  
    it just won't work the way you want it to work maybe.  
    그러나 이 특정 사용 사례에서는  
    원하는 방식으로 작동하지 않을 수 있습니다.

15. But if you were to add any other property, like maybe an id,  
    then you could absolutely do that  
    through that host property.  
    하지만 id와 같은 다른 속성을 추가하려면  
    `host` 속성을 통해 확실히 추가할 수 있습니다.

16. But here for this use case,  
    host is not a tool that will help us.  
    그러나 이 사용 사례에서는  
    `host`가 도움이 되는 도구가 아닙니다.

17. Instead, to style the host element of this component,  
    we should go to the dashboard item component CSS file  
    and use another feature about which you learned earlier.  
    대신, 이 컴포넌트의 호스트 요소를 스타일링하려면  
    대시보드 항목 CSS 파일로 이동하여  
    이전에 배운 다른 기능을 사용해야 합니다.

18. In here, you can use the :host selector,  
    and replace all dashboard-item class occurrences with that  
    also here in the media query.  
    여기에서 `:host` 선택자를 사용하고,  
    `dashboard-item` 클래스가 사용된 모든 곳을  
    미디어 쿼리를 포함하여 교체할 수 있습니다.

19. And with that, we got back our styles  
    and it looks the way it did before,  
    but now again, using this host element styling.  
    이를 통해 스타일이 복원되었고,  
    이전처럼 보이게 되었습니다.  
    하지만 이제는 호스트 요소 스타일링을 사용했습니다.

20. Of course, we can now also revisit the other components  
    and see if we can get rid of some unnecessary wrappers here.  
    이제 다른 컴포넌트도 다시 살펴보고,  
    불필요한 래퍼를 제거할 수 있는지 확인할 수 있습니다.

21. For example, in server-status,  
    there I also have that div with that id.  
    예를 들어, `server-status`에서는  
    id가 있는 div가 있습니다.

22. We could delete that, that div with that id,  
    so that I just have this conditional statement in here.  
    이 id가 있는 div를 삭제하여  
    조건문만 남길 수 있습니다.

23. And then in server-status.component.CSS,  
    I'll replace all those id selectors with :host.  
    그리고 `server-status.component.css`에서  
    모든 id 선택자를 `:host`로 교체하겠습니다.

24. And by the way, there are certain rules in here  
    which won't have any effect yet,  
    but we'll change this soon.  
    참고로, 여기에는 아직 효과가 없는  
    몇 가지 규칙이 있지만, 곧 이를 변경할 것입니다.

25. For the moment, I'll just replace my id selector with :host.  
    현재로서는 id 선택자를 `:host`로 교체하겠습니다.

26. And it turns out I only had one in here.  
    확인해보니 하나만 존재했습니다.

27. Now, here in the new-ticket.component,  
    we could get rid of that form element  
    and rely on our component host element as a wrapper  
    around these input elements.  
    이제 `new-ticket.component`에서는  
    form 요소를 제거하고,  
    input 요소를 감싸는 래퍼로  
    컴포넌트 호스트 요소를 사용할 수 있습니다.

28. But the built-in form element is an element  
    I don't wanna remove here because it makes sense  
    to have it for semantic and accessibility reasons.  
    하지만 기본 제공되는 form 요소는  
    의미론적이고 접근성을 위해 필요하므로  
    제거하고 싶지 않습니다.

29. Our custom component host element  
    won't tell the browser anything,  
    won't tell screen readers anything,  
    and therefore you typically wanna avoid  
    getting rid of semantically important elements.  
    사용자 정의 컴포넌트 호스트 요소는  
    브라우저나 화면 읽기 프로그램에 정보를 제공하지 않으므로  
    의미론적으로 중요한 요소를 제거하지 않는 것이 좋습니다.

30. It's different for things like divs,  
    which have no semantic meaning,  
    but forms, buttons, sections and things like that,  
    you might want to consider keeping those as wrappers  
    instead of replacing them  
    with your component host element as a wrapper.  
    div와 같이 의미가 없는 요소는 다르지만,  
    form, button, section과 같은 요소는  
    컴포넌트 호스트 요소로 대체하는 대신  
    래퍼로 유지하는 것을 고려할 수 있습니다.

31. In the ticket.component, I don't have any markup yet.  
    We didn't work on that yet, so I'll leave it the way it is.  
    `ticket.component`에는 아직 마크업이 없습니다.  
    아직 작업하지 않았으므로 그대로 두겠습니다.

32. In the tickets.component, however,  
    I do want to make a change  
    because in the tickets.component.CSS file,  
    I now want a target host here instead of an element  
    with id tickets, which doesn't exist yet anyways,  
    because that will help us later in this section.  
    하지만 `tickets.component`에서는 변경하고 싶습니다.  
    왜냐하면 `tickets.component.css` 파일에서  
    아직 존재하지 않는 id가 `tickets`인 요소 대신  
    이제 `host`를 타겟팅하려고 하기 때문입니다.  
    이는 이후 섹션에서 도움이 될 것입니다.

33. So here on all my rules, I'm targeting the host element.  
    그래서 여기에서는 모든 규칙에서  
    호스트 요소를 타겟팅하고 있습니다.

34. In the traffic.component,  
    I'll get rid of that div with id traffic here  
    and instead again, target :host just as we did it before.  
    `traffic.component`에서는  
    id가 `traffic`인 div를 제거하고,  
    이전에 했던 것처럼 다시 `:host`를 타겟팅하겠습니다.

35. And with that, if I save that and reload,  
    it again looks the way it did before,  
    but now we're taking advantage of the fact  
    that Angular does render that host element  
    and that allows us to avoid unnecessary wrappers.  
    이를 저장하고 새로고침하면,  
    이전과 같은 모습으로 보이게 됩니다.  
    하지만 이제 Angular가 호스트 요소를 렌더링한다는 점을 활용하여  
    불필요한 래퍼를 제거할 수 있습니다.

---

끝났습니다.
