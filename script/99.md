

1. **So in order to reuse**  
   **this dashboard item component as a wrapper**  
   **for these specific dashboard item components,**  
   **we must make it more reusable.**  
   이러한 특정 대시보드 항목 컴포넌트를 감싸는  
   래퍼로 `dashboard-item` 컴포넌트를 재사용하려면  
   이를 더 재사용 가능하도록 만들어야 합니다.

2. **Specifically, we must make sure that the image source,**  
   **the image alt, and this title here can be set from**  
   **outside this dashboard item component, so to say,**  
   **so that we can use this dashboard item component**  
   **as a custom element in different places**  
   **and then configure the concrete values of the image,**  
   **of the alt text, and of the title,**  
   **depending on where we use it.**  
   구체적으로, 이미지 소스, 이미지 alt 속성,  
   그리고 이 제목이  
   `dashboard-item` 컴포넌트 외부에서 설정될 수 있어야 합니다.  
   그렇게 하면, 이 `dashboard-item` 컴포넌트를  
   다양한 위치에서 커스텀 엘리먼트로 사용하고  
   사용하는 위치에 따라  
   이미지, alt 텍스트, 제목의 값을  
   구성할 수 있습니다.

3. **And you did learn how you can make a component**  
   **reusable and configurable, you can add those inputs.**  
   컴포넌트를 재사용 가능하고  
   구성 가능하게 만드는 방법을 배웠습니다.  
   이를 위해 입력값(inputs)을 추가할 수 있습니다.

4. **And therefore, here in this dashboard item component,**  
   **I want to accept two inputs.**  
   **One for the image, which should give me the data**  
   **for the image file and the alt text,**  
   **and one for the h2 tag.**  
   그래서 이 `dashboard-item` 컴포넌트에서  
   두 개의 입력값을 받고자 합니다.  
   하나는 이미지 파일과 alt 텍스트 데이터를 위한 것이고,  
   다른 하나는 h2 태그를 위한 것입니다.

5. **And you learned that there are two ways**  
   **of registering inputs in Angular.**  
   **You can either use this input decorator**  
   **or the input function.**  
   Angular에서는 입력값을 등록하는 두 가지 방법이 있습니다.  
   `@Input` 데코레이터를 사용하거나  
   `input` 함수를 사용할 수 있습니다.

6. **And I'll again show you both here,**  
   **so that you really are aware of both**  
   **because depending on the Angular version**  
   **you are working with and the project you're working on,**  
   **you might be using different approaches,**  
   **so you must know both.**  
   두 가지 방법을 다시 한번 보여드리겠습니다.  
   사용하는 Angular 버전이나 프로젝트에 따라  
   다른 접근 방식을 사용할 수 있으므로  
   두 가지 방법 모두 알고 있어야 합니다.

7. **So to register an input,**  
   **an attribute of this custom component, so to say,**  
   **you can use the @Input decorator**  
   **followed by the name of the input you wanna accept.**  
   입력값을 등록하려면,  
   이 커스텀 컴포넌트의 속성을 등록하려면  
   `@Input` 데코레이터를 사용하고  
   받고자 하는 입력값의 이름을 지정하면 됩니다.

8. **And that name is up to you.**  
   **And it could, for example, be image for that image data.**  
   입력값의 이름은 자유롭게 정할 수 있습니다.  
   예를 들어, 이미지 데이터를 위한 `image`가 될 수 있습니다.

---

계속 이어가겠습니다.

9. **Then, you should define the type**  
   **of data you expect to get here.**  
   **And I expect to get an object here.**  
   그런 다음, 여기에서 기대하는 데이터 유형을 정의해야 합니다.  
   저는 여기에서 객체(object)를 받을 것으로 예상합니다.

10. **So that's now not an object value I'm creating,**  
    **but since we're on the right side of the colon,**  
    **this now actually is an object type I'm defining.**  
    이는 객체 값을 생성하는 것이 아니라,  
    콜론의 오른쪽에 있기 때문에  
    지금 정의하고 있는 것은 객체 타입입니다.

11. **So I'm defining the shape of the object I expect to get**  
    **as a value on that image property.**  
    그래서 `image` 속성에 값으로 받을 객체의  
    구조를 정의하고 있습니다.

12. **And I expect to get a property value here,**  
    **which is an object which should have an SRC property,**  
    **though this of course is up to you,**  
    **which should be of type string and an alt property,**  
    **which should also be of type string.**  
    여기에서는 객체를 값으로 받을 것이며,  
    객체에는 `src` 속성이 있어야 하고,  
    이는 문자열 타입이어야 합니다.  
    또한, `alt` 속성이 있어야 하며,  
    이것도 문자열 타입이어야 합니다.

13. **So I expect to get such an object as a value for image.**  
    따라서 `image` 속성의 값으로  
    이러한 객체를 받을 것으로 예상합니다.

14. **In addition, this dashboard item component**  
    **really only works if I do get image data**  
    **and therefore image should actually be a required input.**  
    또한, 이 `dashboard-item` 컴포넌트는  
    이미지 데이터를 반드시 받아야만 작동합니다.  
    따라서 `image`는 필수 입력값이어야 합니다.

15. **And you also learned how you can tell Angular**  
    **that it should be required.**  
    **You can pass an object to this input decorator**  
    **and set required to true.**  
    그리고 Angular에게  
    입력값이 필수임을 알리는 방법도 배웠습니다.  
    `@Input` 데코레이터에 객체를 전달하고  
    `required`를 `true`로 설정하면 됩니다.

16. **And this will now tell Angular to throw an error**  
    **if that value should ever be omitted.**  
    이렇게 하면 해당 값이 누락될 경우  
    Angular가 오류를 발생시키도록 할 수 있습니다.

17. **Now since it is required,**  
    **we know that we will get the value here**  
    **and we can therefore add an exclamation mark here**  
    **to tell TypeScript that this will never be undefined,**  
    **which it otherwise doesn't know.**  
    이제 이 값이 필수이므로  
    값이 항상 전달될 것을 알 수 있습니다.  
    따라서 TypeScript에게 이 값이  
    `undefined`가 아님을 알리기 위해  
    느낌표(`!`)를 추가할 수 있습니다.

---

계속 진행하겠습니다.

18. **Now, that's not the only input I want.**  
    **Instead, I also want to get my title input,**  
    **and this should also be required here in this application.**  
    이제 제가 원하는 입력값은 이것뿐만이 아닙니다.  
    대신에 `title` 입력값도 받고 싶으며,  
    이 또한 이 애플리케이션에서 필수 값이어야 합니다.

19. **So I'll set required to true here as well**  
    **and add that exclamation mark.**  
    따라서 여기도 `required`를 `true`로 설정하고  
    느낌표(`!`)를 추가하겠습니다.

20. **And here, I expect to get a simple string as a value.**  
    여기에서는 간단한 문자열 값을 받을 것으로 예상합니다.

21. **Now alternatively, instead of using @Input,**  
    **you could also use that input function.**  
    이제 대안으로, `@Input`을 사용하는 대신  
    `input` 함수를 사용할 수도 있습니다.

22. **In that case, I would still want a property**  
    **that's called image, an input that's called image.**  
    이 경우, 여전히 `image`라는 속성과  
    `image`라는 입력값을 사용하고 싶습니다.

23. **But we'll turn this into an input**  
    **by assigning an initial value instead of using a decorator.**  
    하지만 데코레이터를 사용하는 대신,  
    초기값을 할당하여 이를 입력값으로 만들 것입니다.

24. **And that initial value is the result**  
    **of calling the input function,**  
    **which must be imported from @angular/core.**  
    그리고 이 초기값은 `@angular/core`에서  
    가져와야 하는 `input` 함수를 호출한 결과입니다.

25. **Though this input function is only available**  
    **if you're using Angular 17.1 or later.**  
    그러나 이 `input` 함수는  
    Angular 17.1 이상에서만 사용할 수 있습니다.

26. **Now, when using this input function,**  
    **you can still mark image as a required input**  
    **by adding a dot after the function name**  
    **and calling required,**  
    **so by using this function that's defined on this function, so to say.**  
    이제 이 `input` 함수를 사용할 때도  
    함수 이름 뒤에 점(`.`)을 추가하고  
    `required`를 호출하여  
    `image`를 필수 입력값으로 설정할 수 있습니다.  
    이는 말하자면 함수에 정의된 또 다른 함수를  
    사용하는 것입니다.

27. **And this then tells Angular**  
    **that this should be a required input.**  
    이렇게 하면 Angular는  
    이것이 필수 입력값임을 알게 됩니다.

---

다음 부분도 계속 이어가겠습니다.

28. **And of course, you can and should also still tell Angular**  
    **which type of value will be received as an input here.**  
    물론, Angular에게 입력값으로 어떤 타입의 값이  
    전달될지 알려주는 것도 필요합니다.

29. **And here, you do that by using these angle brackets**  
    **after input before the parentheses**  
    **or after required in this case, before the parentheses.**  
    여기서 이를 알리려면  
    `input` 함수 뒤나, 이 경우 `required` 뒤에  
    꺾쇠 괄호(`<>`)를 사용하고  
    괄호 앞에 타입을 정의하면 됩니다.

30. **And you then put your type definition**  
    **between those angle brackets.**  
    그런 다음, 꺾쇠 괄호 안에  
    타입 정의를 입력하면 됩니다.

31. **This is a so-called generic type here,**  
    **or you're setting a generic type value to be precise,**  
    **which here simply means that you give TypeScript**  
    **extra information about which type of value**  
    **the input will eventually receive.**  
    이것을 제네릭 타입이라고 부르며,  
    정확히는 제네릭 타입 값을 설정하는 것입니다.  
    이는 입력값이 어떤 타입의 값을 받을지에 대한  
    추가 정보를 TypeScript에 제공하는 것을 의미합니다.

32. **Well and then we can also add the title input here**  
    **by using input.required.**  
    그리고 여기서도 `input.required`를 사용하여  
    `title` 입력값을 추가할 수 있습니다.

33. **And here, I expect to get a string.**  
    여기에서는 문자열을 받을 것으로 예상합니다.

---

**번역이 완료되었습니다.**
