

1. So when do I want to add a ticket to this array here?  
   이 배열에 티켓을 추가하고 싶은 때는 언제일까요?

2. Well, whenever the user enters the data for a new ticket and clicked submit.  
   사용자가 새 티켓 데이터를 입력하고 제출 버튼을 클릭했을 때입니다.

3. So onSubmit of the `NewTicketComponent`, I wanna emit a custom event to which I can listen from inside the `TicketsComponent`.  
   따라서 `NewTicketComponent`의 onSubmit 이벤트에서, `TicketsComponent` 내부에서 들을 수 있는 사용자 정의 이벤트를 발생시키고 싶습니다.

4. And therefore here, we can and should add a new property.  
   따라서 여기서는 새로운 속성을 추가해야 합니다.

5. It could be named `add`, but the name is up to you, and it should be a custom event.  
   이 속성은 `add`라고 이름 지을 수 있지만, 이름은 자유롭게 정할 수 있습니다. 이는 사용자 정의 이벤트여야 합니다.

6. So we can use the `@Output()` decorator and set this to be a new `EventEmitter` where `Output` and `EventEmitter` are both imported from Angular core.  
   그래서 `@Output()` 데코레이터를 사용해 Angular Core에서 가져온 `EventEmitter`의 새 인스턴스로 설정할 수 있습니다.

7. Alternatively, we can set `add` equal to the result of calling the `output` function.  
   또는 `add`를 `output` 함수를 호출한 결과와 동일하게 설정할 수도 있습니다.

8. That's the more modern way of registering that output, as explained before in this course.  
   이는 이전에 이 강의에서 설명한 대로 출력(output)을 등록하는 더 현대적인 방법입니다.

9. We should then also make it clear which kind of data will be emitted here.  
   그리고 여기서 어떤 종류의 데이터가 발생할지 명확히 해야 합니다.

10. And that could be an object where we'll have a `title`, which is a string and a `text` that is a string, let's say.  
    예를 들어, `title`과 `text` 속성이 문자열(string)인 객체일 수 있습니다.

11. And of course, if you would be using that output decorator-based approach, you should also set that type here on `EventEmitter` to tell TypeScript which kind of data will eventually be emitted.  
    물론, 출력 데코레이터 기반 접근 방식을 사용할 경우, TypeScript에 어떤 데이터가 발생할지 명확히 하기 위해 `EventEmitter`에 타입을 설정해야 합니다.

12. Now, with that, we can use this `add` property here in `onSubmit` to call `this.add.emit` and emit this object.  
    이제 `onSubmit`에서 `this.add.emit`을 호출해 이 객체를 발생시키기 위해 `add` 속성을 사용할 수 있습니다.

13. Where I set the `title` to the title I'm getting here as a parameter, and the `text` to the `ticketText`.  
    여기서 `title`은 매개변수로 전달된 제목 값으로 설정하고, `text`는 `ticketText`로 설정합니다.

14. And that should be `string` with a lowercase `s` here.  
    여기서 `string`은 소문자 `s`로 작성되어야 합니다.

15. That was a little mistake from my side. The lowercase `s` is important, but with that, I'm then emitting this event.  
    제 실수로 약간 잘못 작성했는데, 소문자 `s`가 중요합니다. 이로써 이벤트를 발생시킬 수 있습니다.

16. Now in the `TicketsComponent`, we can listen to that event in the template.  
    이제 `TicketsComponent`에서 템플릿에서 해당 이벤트를 들을 수 있습니다.

17. So on the `app-new-ticket` Component, we can listen to that `add` event and for example, trigger an `onAdd` method.  
    그래서 `app-new-ticket` 컴포넌트에서 해당 `add` 이벤트를 듣고, 예를 들어 `onAdd` 메서드를 실행할 수 있습니다.

18. And to then forward that emitted data to that method, we can use the special `$event` variable that is created by Angular here.  
    그리고 발생한 데이터를 해당 메서드로 전달하려면, Angular에서 생성하는 특별한 `$event` 변수를 사용할 수 있습니다.

19. And then go to the `TicketsComponent` and add this `onAdd` method,  
    그런 다음 `TicketsComponent`로 가서 이 `onAdd` 메서드를 추가합니다.

20. Where I will get that ticket data, which will have that shape that we set up here in `new-ticket`, in the `NewTicketComponent`.  
    여기서 우리는 `NewTicketComponent`의 `new-ticket`에서 설정한 형태의 티켓 데이터를 받을 것입니다.

21. So this shape here, this is the type definition of the data we're emitting.  
    이 형태는 우리가 발생시키는 데이터의 타입 정의입니다.

22. So in the `TicketsComponent`, that's the shape of the data I'm receiving.  
    그래서 `TicketsComponent`에서는 이 데이터 형태를 받게 됩니다.

23. And we could outsource this into a separate file.  
    이 타입 정의를 별도의 파일로 분리할 수도 있습니다.

24. Here I'll just duplicate and copy and paste it.  
    여기서는 단순히 복사하여 붙여넣겠습니다.

25. But now we got the `Ticket` data here in the `TicketsComponent`,  
    하지만 이제 `TicketsComponent`에서 `Ticket` 데이터를 가지게 됩니다.

26. And therefore of course we can create a new ticket constant here, which should be of type `Ticket`.  
    따라서 여기에서 타입이 `Ticket`인 새 티켓 상수를 생성할 수 있습니다.

27. So our custom type here, where the title will hold the value of `ticketData.title` and request will get `ticketData.text` as a value,  
    그래서 우리의 커스텀 타입에서 `title`은 `ticketData.title` 값을 가지며, `request`는 `ticketData.text` 값을 가집니다.

28. But where we also need to add an `id` and then also thereafter the `status`.  
    하지만 여기에 `id`와 이후에 `status`를 추가해야 합니다.

29. Now for the `id`, I'll use `Math.random()` here, and convert this to a string.  
    이제 `id`로는 여기서 `Math.random()`을 사용하고 이를 문자열로 변환하겠습니다.

30. And of course this doesn't give me a perfectly unique `id` since theoretically, the same value could be generated twice.  
    물론, 이 방식은 완벽히 고유한 `id`를 보장하지 않습니다. 이론적으로 동일한 값이 두 번 생성될 수 있기 때문입니다.

31. But for this dummy app it's good enough.  
    하지만 이 더미 앱에서는 충분히 적합합니다.

32. The `status` then is `closed` or `open` and I'll start with `open` here.  
    `status`는 `closed` 또는 `open` 값 중 하나이며, 여기서는 `open`으로 시작하겠습니다.

33. Now this `Ticket` object can be added to this `tickets` array,  
    이제 이 `Ticket` 객체를 `tickets` 배열에 추가할 수 있습니다.

34. So we can reach out to `this.tickets` and push this ticket into this array.  
    그래서 `this.tickets`를 호출하여 이 배열에 해당 티켓을 추가합니다.

35. With that, we're then managing and updating this `tickets` array,  
    이를 통해 `tickets` 배열을 관리하고 업데이트합니다.

36. And we can then, as a next step, output it here in the template of that Component.  
    그리고 다음 단계로, 이 컴포넌트의 템플릿에서 이를 출력할 수 있습니다.

---

번역이 완료되었습니다! 추가 요청이 있으면 알려주세요! 😊
