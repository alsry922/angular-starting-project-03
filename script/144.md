1. Now with all that and with all that usage of inputs and outputs,  
   이제 입력(Input)과 출력(Output)을 모두 활용한 상태에서,

2. I'll go back to that new ticket component,  
   새로운 티켓 컴포넌트로 돌아가

3. and I wanna revisit the approach we're using for extracting the entered input data.  
   입력 데이터를 추출하는 현재 접근 방식을 다시 살펴보고 싶습니다.

4. I'm currently doing this with template variables like this,  
   현재 템플릿 변수(template variables)를 사용해 작업하고 있습니다.

5. and that approach is absolutely fine, of course.  
   물론, 이 접근 방식은 전혀 문제가 없습니다.

6. It works fine and there is no reason to change it here.  
   잘 작동하며, 여기서 변경할 이유는 없습니다.

7. But earlier in the course you learned about two-way binding,  
   하지만 강의 초반에 양방향 바인딩(two-way binding)에 대해 배웠습니다.

8. and I wanna revisit this here and then also show you  
   여기서 이를 다시 살펴보고,

9. how you can make your own components two-way bindable,  
   자신의 컴포넌트를 양방향 바인딩 가능하게 만드는 방법을 보여드리고 싶습니다.

10. which is something we haven't done before.  
    이는 우리가 이전에는 해보지 않았던 작업입니다.

11. But let's start by revisiting two-way binding on input elements.  
    하지만 우선 입력 요소에서의 양방향 바인딩을 다시 살펴보겠습니다.

12. As you learned earlier in the course,  
    강의 초반에 배웠듯이,

13. you can use the special `ngModel` directive,  
    `ngModel`이라는 특수 디렉티브를 사용할 수 있습니다.

14. which is unlocked by the forms module to two-way bind input elements  
    이는 forms 모듈로 활성화되며, 입력 요소를 양방향 바인딩합니다.

15. or related elements, so text area elements and so on.  
    또는 관련 요소들, 예를 들어 텍스트 영역(text area) 요소 등을 바인딩합니다.

---

문장을 끊어서 번역하고 있습니다. 이어서 진행하겠습니다! 😊

16. And we can use this here in the new ticket component  
    그리고 이를 새로운 티켓 컴포넌트에서 사용할 수 있습니다.

17. to add some new properties that should be managed with help of two-way binding.  
    양방향 바인딩을 통해 관리할 새로운 속성을 추가할 수 있습니다.

18. And you can either use signals or non-signal properties,  
    그리고 신호(signal) 속성이나 비신호(non-signal) 속성을 사용할 수 있습니다.

19. as you also saw before in the course.  
    이는 강의에서 이미 보았던 내용입니다.

20. And here I'll start with non-signal properties.  
    여기서는 비신호 속성으로 시작하겠습니다.

21. So I will add an `enteredTitle` property,  
    따라서 `enteredTitle` 속성을 추가하겠습니다.

22. which should be an empty string initially,  
    초기 값으로는 빈 문자열을 설정하겠습니다.

23. and an `enteredText` property,  
    그리고 `enteredText` 속성도 추가하겠습니다.

24. which also is an empty string initially.  
    이 속성 역시 초기 값으로 빈 문자열을 갖습니다.

25. Back in the new ticket component template,  
    새로운 티켓 컴포넌트 템플릿으로 돌아가서,

26. we can then use `ngModel` with that two-way binding syntax,  
    이제 `ngModel`을 사용해 양방향 바인딩 구문을 활용할 수 있습니다.

27. which looks like this: square brackets around parentheses around `ngModel`,  
    이는 `ngModel`을 괄호와 대괄호로 감싼 형태로 나타납니다.

28. to set and bind the `enteredTitle` here  
    여기서 `enteredTitle`을 설정하고 바인딩하며,

29. and do it on the text area to set and bind the `enteredText`.  
    텍스트 영역에서도 `enteredText`를 설정하고 바인딩합니다.

30. Now with that we can actually get rid of the parameters  
    이제 이를 통해 기존의 매개변수를 제거할 수 있습니다.

31. that are passed to `onSubmit`  
    이는 `onSubmit`으로 전달되던 매개변수입니다.

32. and get rid of the title input and text input template variables,  
    그리고 제목 입력과 텍스트 입력 템플릿 변수를 제거할 수 있습니다.

33. because I'm now switching to using two-way binding for getting that user input.  
    이제 사용자 입력을 양방향 바인딩으로 처리하기 때문입니다.

---

다음 문장도 동일하게 번역을 이어가겠습니다! 😊

34. So in the new ticket component TypeScript file,  
    따라서 새로운 티켓 컴포넌트의 TypeScript 파일에서,

35. in `onSubmit`, we should no longer expect those parameters.  
    `onSubmit`에서는 더 이상 해당 매개변수를 기대하지 않아도 됩니다.

36. And instead, for emitting the `add` event,  
    대신 `add` 이벤트를 발생시킬 때,

37. we now wanna reference `enteredTitle` and `enteredText` here.  
    이제 여기서 `enteredTitle`과 `enteredText`를 참조하면 됩니다.

38. With that, if you save everything,  
    이를 저장한 후,

39. you should get the same behavior as before.  
    이전과 동일한 동작을 확인할 수 있습니다.

40. I can submit these tickets,  
    티켓을 제출할 수 있으며,

41. and everything works the way it did before.  
    모든 것이 이전과 동일하게 작동합니다.

42. We could now also clear the form in a different way,  
    이제 양식을 초기화하는 또 다른 방법도 사용할 수 있습니다.

43. because now instead of calling `reset` on the form,  
    왜냐하면 이제 폼에서 `reset`을 호출하는 대신,

44. since I'm using two-way binding,  
    양방향 바인딩을 사용하고 있으므로,

45. which means I'm not just listening to changes to those inputs,  
    이는 입력 값의 변경을 단순히 감지하는 것만이 아니라,

46. but I can also send new values back into them.  
    새로운 값을 입력 필드에 다시 전달할 수도 있다는 것을 의미합니다.

47. We can clear both inputs by resetting `enteredTitle`  
    따라서 `enteredTitle`을 초기값인 빈 문자열로 재설정하고,

48. and `enteredText` back to empty strings  
    `enteredText`도 빈 문자열로 재설정함으로써,

49. after we extracted their values.  
    값을 추출한 후 두 입력 필드를 초기화할 수 있습니다.

50. So here after calling `emit`,  
    따라서 여기서 `emit`을 호출한 후,

51. we can set `enteredTitle` back to an empty string  
    `enteredTitle`을 빈 문자열로 설정하고,

52. and `enteredText` back to an empty string.  
    `enteredText`도 빈 문자열로 설정합니다.

53. And by doing this thanks to two-way binding,  
    양방향 바인딩 덕분에 이렇게 하면,

54. you'll see that the form will still be reset.  
    폼이 여전히 초기화되는 것을 볼 수 있습니다.

55. Because yeah, as mentioned,  
    왜냐하면 앞서 언급했듯이,

56. we're passing values back into those inputs.  
    새로운 값을 입력 필드로 다시 전달하고 있기 때문입니다.

57. But that's of course nothing new.  
    하지만 이는 새로운 내용이 아닙니다.

58. You did learn about two-way binding before.  
    이미 이전에 양방향 바인딩에 대해 배웠습니다.

59. Now, however, we'll set up custom two-way binding for our own component.  
    이제는 우리 컴포넌트에 맞는 맞춤형 양방향 바인딩을 설정할 것입니다.

---

번역이 완료되었습니다! 문장을 끊어서 쉽게 이해하고 활용할 수 있도록 구성했습니다. 추가 요청이 있다면 말씀해주세요! 😊
