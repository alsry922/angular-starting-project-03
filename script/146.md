1. So that's how you can set up custom two-way binding for your own property in your own Component with the input and output decorators.  
   ì´ë ‡ê²Œ ì…ë ¥(`@Input`)ê³¼ ì¶œë ¥(`@Output`) ë°ì½”ë ˆì´í„°ë¥¼ ì‚¬ìš©í•˜ì—¬, ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©ì ì •ì˜ ì–‘ë°©í–¥ ë°”ì¸ë”©ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

2. But depending on the Angular version you're using, you can actually use an alternative, more modern, and simpler syntax.  
   í•˜ì§€ë§Œ ì‚¬ìš© ì¤‘ì¸ Angular ë²„ì „ì— ë”°ë¼ ë” í˜„ëŒ€ì ì´ê³  ê°„ë‹¨í•œ êµ¬ë¬¸ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

3. Specifically, you must be using Angular version 17.2 or later,  
   íŠ¹íˆ Angular 17.2 ì´ìƒ ë²„ì „ì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

4. and if you're doing that, you can set up this two-way binding in a way easier way.  
   ì´ë ‡ê²Œ í•˜ë©´ í›¨ì”¬ ë” ê°„ë‹¨í•˜ê²Œ ì–‘ë°©í–¥ ë°”ì¸ë”©ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

5. You still need to create the two-way bindable property in the Component that should receive it,  
   ì—¬ì „íˆ ì–‘ë°©í–¥ ë°”ì¸ë”© ê°€ëŠ¥í•œ ì†ì„±ì„ í•´ë‹¹ ì»´í¬ë„ŒíŠ¸ì—ì„œ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤.

6. so here in the `RectComponent`,  
   ì—¬ê¸°ì„œëŠ” `RectComponent`ì—ì„œ ì‘ì—…í•©ë‹ˆë‹¤.

7. but then you assign an initial value to that property that's created with help of the `model` function,  
   ê·¸ëŸ¬ë‚˜ ì†ì„±ì— ì´ˆê¸° ê°’ì„ í• ë‹¹í•  ë•Œ `model` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

8. and that is a function that must be imported from `@angular/core`,  
   ì´ í•¨ìˆ˜ëŠ” `@angular/core`ì—ì„œ ê°€ì ¸ì™€ì•¼ í•©ë‹ˆë‹¤.

9. and that's only available if you are using Angular 17.2 or newer.  
   ì´ í•¨ìˆ˜ëŠ” Angular 17.2 ì´ìƒì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

10. This `model` function will in the end make this `size` property two-way bindable,  
    `model` í•¨ìˆ˜ëŠ” ê²°êµ­ `size` ì†ì„±ì„ ì–‘ë°©í–¥ ë°”ì¸ë”© ê°€ëŠ¥í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤.

11. and it saves you the effort of creating separate inputs and outputs.  
    ì´ë¥¼ í†µí•´ ë³„ë„ë¡œ ì…ë ¥ê³¼ ì¶œë ¥ ì†ì„±ì„ ìƒì„±í•  í•„ìš”ê°€ ì—†ì–´ì§‘ë‹ˆë‹¤.

12. Now, you should still let Angular know which kind of data will be handled by `model`,  
    ì—¬ì „íˆ Angularì— `model`ì´ ì²˜ë¦¬í•  ë°ì´í„°ì˜ ìœ í˜•ì„ ì•Œë ¤ì•¼ í•©ë‹ˆë‹¤.

13. and you can actually also call a `required` method on this `model` here  
    ê·¸ë¦¬ê³  ì—¬ê¸°ì„œ `model` í•¨ìˆ˜ì— `required` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

14. to make sure that some value must be passed for this `size` property to this Component.  
    ì´ë¥¼ í†µí•´ ë°˜ë“œì‹œ ì´ `size` ì†ì„±ì— ê°’ì´ ì „ë‹¬ë˜ë„ë¡ ë³´ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

15. You of course don't have to make it required, but you can,  
    ë¬¼ë¡  í•„ìˆ˜ë¡œ ì„¤ì •í•˜ì§€ ì•Šì•„ë„ ë˜ì§€ë§Œ, ì„¤ì •í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

16. and since I used `required` before, I'll also use it here on `model`.  
    ì´ì „ì— `required`ë¥¼ ì‚¬ìš©í–ˆê¸° ë•Œë¬¸ì— ì—¬ê¸°ì„œë„ `model`ì— ì‚¬ìš©í•˜ê² ìŠµë‹ˆë‹¤.

---

17. Now, with this setup like this, `size` will be a so-called `ModelSignal`.  
    ì´ì œ ì´ë ‡ê²Œ ì„¤ì •í•˜ë©´, `size`ëŠ” `ModelSignal`ì´ë¼ëŠ” í˜•íƒœê°€ ë©ë‹ˆë‹¤.

18. So it says Signal in the end, and therefore,  
    ì´ëŠ” ê²°êµ­ ì‹ í˜¸(Signal)ì´ë©°,

19. you can use it in the template like all those Signals  
    ëª¨ë“  ì‹ í˜¸ì™€ ë§ˆì°¬ê°€ì§€ë¡œ í…œí”Œë¦¿ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

20. by executing it like a function  
    ì´ë¥¼ í•¨ìˆ˜ì²˜ëŸ¼ ì‹¤í–‰í•˜ë©´ ë©ë‹ˆë‹¤.

---

### ë‚˜ë¨¸ì§€ë„ ê³„ì† ì ì ˆíˆ ë²ˆì—­í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜Š

21. to have Angular set up a subscription  
    Angularê°€ êµ¬ë…(subscription)ì„ ì„¤ì •í•˜ë„ë¡ í•˜ê³ ,

22. so that whenever the value managed by that Signal changes,  
    í•´ë‹¹ ì‹ í˜¸(Signal)ê°€ ê´€ë¦¬í•˜ëŠ” ê°’ì´ ë³€ê²½ë  ë•Œë§ˆë‹¤,

23. this Component's template here will be reevaluated and updated automatically by Angular.  
    ì´ ì»´í¬ë„ŒíŠ¸ì˜ í…œí”Œë¦¿ì´ Angularì— ì˜í•´ ë‹¤ì‹œ í‰ê°€ë˜ê³  ìë™ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.

24. So that's how we must use `size` in the template now,  
    ë”°ë¼ì„œ ì´ì œ í…œí”Œë¦¿ì—ì„œ `size`ë¥¼ ì´ë ‡ê²Œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

25. and we also need to change this code in `onReset`,  
    ê·¸ë¦¬ê³  `onReset` ë©”ì„œë“œì˜ ì½”ë“œë¥¼ ë³€ê²½í•´ì•¼ í•©ë‹ˆë‹¤.

26. because instead of emitting some event here,  
    ì—¬ê¸°ì—ì„œ ì´ë²¤íŠ¸ë¥¼ ë°©ì¶œí•˜ëŠ” ëŒ€ì‹ ,

27. you now simply must update this Signal  
    ì´ì œ ì´ ì‹ í˜¸(Signal)ë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•©ë‹ˆë‹¤.

28. like you always update Signals by using the `set` method or by using the `update` method, both work.  
    ì‹ í˜¸ë¥¼ ì—…ë°ì´íŠ¸í•  ë•Œ í•­ìƒ ì‚¬ìš©í•˜ëŠ” `set` ë©”ì„œë“œë‚˜ `update` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

29. And here, I want to use `set`,  
    ì—¬ê¸°ì„œëŠ” `set` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ê² ìŠµë‹ˆë‹¤.

30. and set this to a new value where `width` is `200` and `height` is `100`, for example.  
    ì˜ˆë¥¼ ë“¤ì–´, `width`ë¥¼ `200`, `height`ë¥¼ `100`ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.

---

31. And that's all, this will update the Signal,  
    ì´ë ‡ê²Œ í•˜ë©´ ì‹ í˜¸ê°€ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.

32. and Angular will then automatically be notified about this update  
    AngularëŠ” ì´ ì—…ë°ì´íŠ¸ë¥¼ ìë™ìœ¼ë¡œ ê°ì§€í•˜ê³ ,

33. in the Component that provided the value for the two-way binding, so in the `AppComponent`.  
    ì–‘ë°©í–¥ ë°”ì¸ë”© ê°’ì„ ì œê³µí•œ ì»´í¬ë„ŒíŠ¸, ì¦‰ `AppComponent`ì—ì„œ ì´ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.

34. And it doesn't matter whether you are using a Signal here or not,  
    ì—¬ê¸°ì—ì„œ ì‹ í˜¸ë¥¼ ì‚¬ìš©í•˜ë“  ê·¸ë ‡ì§€ ì•Šë“  ìƒê´€ì—†ìŠµë‹ˆë‹¤.

35. you can absolutely use a non-Signal value  
    ì‹ í˜¸ê°€ ì•„ë‹Œ ê°’ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

36. and pass that as a value for this model-based `size` property and it will still work fine.  
    ì´ ëª¨ë¸ ê¸°ë°˜ `size` ì†ì„±ì— ê°’ì„ ì „ë‹¬í•˜ë©´ ì—¬ì „íˆ ì˜ ì‘ë™í•  ê²ƒì…ë‹ˆë‹¤.

---

37. Alternatively, you could also be working with a Signal here, it doesn't matter.  
    ë˜ëŠ” ì—¬ê¸°ì„œ ì‹ í˜¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìœ¼ë©°, ì´ëŠ” ìƒê´€ì—†ìŠµë‹ˆë‹¤.

38. Angular will make sure that it works either way.  
    AngularëŠ” ì–´ë–¤ ë°©ì‹ìœ¼ë¡œë“  ì‘ë™í•˜ë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤.

39. Well, and therefore with that, if you save that,  
    ë”°ë¼ì„œ ì´ë ‡ê²Œ ì €ì¥í•œ í›„,

40. if you go back and reload,  
    ë‹¤ì‹œ ëŒì•„ê°€ì„œ ìƒˆë¡œê³ ì¹¨í•˜ë©´,

---

41. you can still change those dimensions from inside here,  
    ì—¬ì „íˆ ì—¬ê¸° ì…ë ¥ í•„ë“œì—ì„œ í¬ê¸°ë¥¼ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

42. as you can see from inside these input fields,  
    ì…ë ¥ í•„ë“œì—ì„œ í¬ê¸°ë¥¼ ì¡°ì •í•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

43. but if you then click on this, it's still also sent back to that `AppComponent`  
    ê·¸ëŸ¬ë‚˜ ì‚¬ê°í˜•ì„ í´ë¦­í•˜ë©´ ê°’ì´ ì—¬ì „íˆ `AppComponent`ë¡œ ì „ë‹¬ë©ë‹ˆë‹¤.

44. and it is being reset.  
    ê·¸ë¦¬ê³  ê°’ì´ ì¬ì„¤ì •ë©ë‹ˆë‹¤.

45. So with that, the two-way binding still works as before,  
    ì´ë ‡ê²Œ í•˜ë©´ ì–‘ë°©í–¥ ë°”ì¸ë”©ì€ ì´ì „ê³¼ ë™ì¼í•˜ê²Œ ì‘ë™í•˜ë©°,

46. but now with even less code, thanks to this modern `model` function.  
    ë” ì ì€ ì½”ë“œë¡œ, ì´ ìµœì‹  `model` í•¨ìˆ˜ ë•ë¶„ì— êµ¬í˜„ë©ë‹ˆë‹¤.

---

ë²ˆì—­ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! ë¬¸ì¥ì„ ì ì ˆíˆ ëŠì–´, ì´í•´í•˜ê¸° ì‰½ê²Œ ì‘ì„±í–ˆìŠµë‹ˆë‹¤. ì¶”ê°€ë¡œ ê¶ê¸ˆí•œ ì ì´ë‚˜ ìš”ì²­ ì‚¬í•­ì´ ìˆë‹¤ë©´ ë§ì”€í•´ì£¼ì„¸ìš”! ğŸ˜Š
