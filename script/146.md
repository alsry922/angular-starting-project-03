1. So that's how you can set up custom two-way binding for your own property in your own Component with the input and output decorators.  
   이렇게 입력(`@Input`)과 출력(`@Output`) 데코레이터를 사용하여, 컴포넌트에서 사용자 정의 양방향 바인딩을 설정할 수 있습니다.

2. But depending on the Angular version you're using, you can actually use an alternative, more modern, and simpler syntax.  
   하지만 사용 중인 Angular 버전에 따라 더 현대적이고 간단한 구문을 사용할 수도 있습니다.

3. Specifically, you must be using Angular version 17.2 or later,  
   특히 Angular 17.2 이상 버전을 사용해야 합니다.

4. and if you're doing that, you can set up this two-way binding in a way easier way.  
   이렇게 하면 훨씬 더 간단하게 양방향 바인딩을 설정할 수 있습니다.

5. You still need to create the two-way bindable property in the Component that should receive it,  
   여전히 양방향 바인딩 가능한 속성을 해당 컴포넌트에서 만들어야 합니다.

6. so here in the `RectComponent`,  
   여기서는 `RectComponent`에서 작업합니다.

7. but then you assign an initial value to that property that's created with help of the `model` function,  
   그러나 속성에 초기 값을 할당할 때 `model` 함수를 사용합니다.

8. and that is a function that must be imported from `@angular/core`,  
   이 함수는 `@angular/core`에서 가져와야 합니다.

9. and that's only available if you are using Angular 17.2 or newer.  
   이 함수는 Angular 17.2 이상에서만 사용할 수 있습니다.

---

10. This `model` function will in the end make this `size` property two-way bindable,  
    `model` 함수는 결국 `size` 속성을 양방향 바인딩 가능하게 만듭니다.

11. and it saves you the effort of creating separate inputs and outputs.  
    이를 통해 별도로 입력과 출력 속성을 생성할 필요가 없어집니다.

12. Now, you should still let Angular know which kind of data will be handled by `model`,  
    여전히 Angular에 `model`이 처리할 데이터의 유형을 알려야 합니다.

13. and you can actually also call a `required` method on this `model` here  
    그리고 여기서 `model` 함수에 `required` 메서드를 호출할 수도 있습니다.

14. to make sure that some value must be passed for this `size` property to this Component.  
    이를 통해 반드시 이 `size` 속성에 값이 전달되도록 보장할 수 있습니다.

15. You of course don't have to make it required, but you can,  
    물론 필수로 설정하지 않아도 되지만, 설정할 수도 있습니다.

16. and since I used `required` before, I'll also use it here on `model`.  
    이전에 `required`를 사용했기 때문에 여기서도 `model`에 사용하겠습니다.

---

17. Now, with this setup like this, `size` will be a so-called `ModelSignal`.  
    이제 이렇게 설정하면, `size`는 `ModelSignal`이라는 형태가 됩니다.

18. So it says Signal in the end, and therefore,  
    이는 결국 신호(Signal)이며,

19. you can use it in the template like all those Signals  
    모든 신호와 마찬가지로 템플릿에서 사용할 수 있습니다.

20. by executing it like a function  
    이를 함수처럼 실행하면 됩니다.

---

### 나머지도 계속 적절히 번역하겠습니다! 😊

21. to have Angular set up a subscription  
    Angular가 구독(subscription)을 설정하도록 하고,

22. so that whenever the value managed by that Signal changes,  
    해당 신호(Signal)가 관리하는 값이 변경될 때마다,

23. this Component's template here will be reevaluated and updated automatically by Angular.  
    이 컴포넌트의 템플릿이 Angular에 의해 다시 평가되고 자동으로 업데이트됩니다.

24. So that's how we must use `size` in the template now,  
    따라서 이제 템플릿에서 `size`를 이렇게 사용해야 합니다.

25. and we also need to change this code in `onReset`,  
    그리고 `onReset` 메서드의 코드를 변경해야 합니다.

26. because instead of emitting some event here,  
    여기에서 이벤트를 방출하는 대신,

27. you now simply must update this Signal  
    이제 이 신호(Signal)를 업데이트해야 합니다.

28. like you always update Signals by using the `set` method or by using the `update` method, both work.  
    신호를 업데이트할 때 항상 사용하는 `set` 메서드나 `update` 메서드를 사용할 수 있습니다.

29. And here, I want to use `set`,  
    여기서는 `set` 메서드를 사용하겠습니다.

30. and set this to a new value where `width` is `200` and `height` is `100`, for example.  
    예를 들어, `width`를 `200`, `height`를 `100`으로 설정합니다.

---

31. And that's all, this will update the Signal,  
    이렇게 하면 신호가 업데이트됩니다.

32. and Angular will then automatically be notified about this update  
    Angular는 이 업데이트를 자동으로 감지하고,

33. in the Component that provided the value for the two-way binding, so in the `AppComponent`.  
    양방향 바인딩 값을 제공한 컴포넌트, 즉 `AppComponent`에서 이를 처리합니다.

34. And it doesn't matter whether you are using a Signal here or not,  
    여기에서 신호를 사용하든 그렇지 않든 상관없습니다.

35. you can absolutely use a non-Signal value  
    신호가 아닌 값을 사용할 수도 있습니다.

36. and pass that as a value for this model-based `size` property and it will still work fine.  
    이 모델 기반 `size` 속성에 값을 전달하면 여전히 잘 작동할 것입니다.

---

37. Alternatively, you could also be working with a Signal here, it doesn't matter.  
    또는 여기서 신호를 사용할 수도 있으며, 이는 상관없습니다.

38. Angular will make sure that it works either way.  
    Angular는 어떤 방식으로든 작동하도록 보장합니다.

39. Well, and therefore with that, if you save that,  
    따라서 이렇게 저장한 후,

40. if you go back and reload,  
    다시 돌아가서 새로고침하면,

---

41. you can still change those dimensions from inside here,  
    여전히 여기 입력 필드에서 크기를 변경할 수 있습니다.

42. as you can see from inside these input fields,  
    입력 필드에서 크기를 조정하는 것을 확인할 수 있습니다.

43. but if you then click on this, it's still also sent back to that `AppComponent`  
    그러나 사각형을 클릭하면 값이 여전히 `AppComponent`로 전달됩니다.

44. and it is being reset.  
    그리고 값이 재설정됩니다.

45. So with that, the two-way binding still works as before,  
    이렇게 하면 양방향 바인딩은 이전과 동일하게 작동하며,

46. but now with even less code, thanks to this modern `model` function.  
    더 적은 코드로, 이 최신 `model` 함수 덕분에 구현됩니다.

---

번역이 완료되었습니다! 문장을 적절히 끊어, 이해하기 쉽게 작성했습니다. 추가로 궁금한 점이나 요청 사항이 있다면 말씀해주세요! 😊
