1. **So how can we get hold of the values**  
   **that were entered by the user into input and textarea?**  
   사용자가 입력한 값(input과 textarea)을  
   어떻게 가져올 수 있을까요?

2. **Well, there are different ways of getting hold.**  
   이를 가져오는 다양한 방법이 있습니다.

3. **One way would be to use two-way binding with `ngModel`.**  
   한 가지 방법은 `ngModel`을 사용한 양방향 바인딩입니다.

4. **And you did learn about that earlier before,**  
   **and I'll get back to that in the future.**  
   이전에 이에 대해 배웠고,  
   이후에 다시 다룰 것입니다.

5. **But for the moment, I wanna show you an alternative approach**  
   **because this section here is about diving deeper**  
   **into Angular and working with templates**  
   **and the user interface.**  
   하지만 지금은 다른 방법을 보여드리고 싶습니다.  
   이 섹션에서는 Angular, 템플릿,  
   그리고 사용자 인터페이스에 대해 더 깊이 다루고 있기 때문입니다.

6. **And therefore, I wanna show you an alternative way**  
   **of extracting the values**  
   **that have been entered into those inputs**  
   **when they are submitted.**  
   그래서 입력 필드에 입력된 값을  
   제출 시 추출하는 또 다른 방법을 소개하려 합니다.

7. **And one alternative way of getting hold**  
   **of the entire element actually,**  
   **and therefore, also if we want to of the value**  
   **that has been entered here is to store that element**  
   **or a reference to that element**  
   **in a so-called template variable,**  
   **which is a feature offered by Angular,**  
   **not a standard browser feature.**  
   요소 전체를 가져오고,  
   입력된 값까지 다룰 수 있는 대안은  
   해당 요소나 그 요소의 참조를  
   "템플릿 변수(template variable)"에 저장하는 것입니다.  
   이는 브라우저의 표준 기능이 아니라,  
   Angular에서 제공하는 기능입니다.

8. **And you do store an element in a template variable**  
   **by adding a special attribute to that element,**  
   **an attribute that starts with a hashtag.**  
   템플릿 변수에 요소를 저장하려면,  
   해당 요소에 해시태그(#)로 시작하는  
   특별한 속성을 추가해야 합니다.

9. **That's important.**  
   **And then any name of your choice, like `titleInput`,**  
   **but this is up to you.**  
   이 해시태그는 중요하며,  
   그 뒤에 원하는 이름을 붙이면 됩니다.  
   예: `titleInput` (이 이름은 임의로 정할 수 있습니다).

10. **The hashtag at the beginning is important though.**  
    **This creates a template variable**  
    **and that's an Angular feature where the element**  
    **to which this variable,**  
    **this special attribute here is added,**  
    **is stored in that variable.**  
    하지만 해시태그는 필수입니다.  
    이것이 템플릿 변수를 생성하며,  
    이 변수에 추가된 속성을 가진 요소가 저장됩니다.  
    이는 Angular의 기능입니다.

11. **And that variable is now available anywhere here**  
    **in that template, which means we can, for example,**  
    **pass it to `onSubmit` without the hashtag here though.**  
    이 변수는 이제 템플릿 어디에서든 사용할 수 있습니다.  
    예를 들어, 이를 `onSubmit` 메서드에 전달할 수 있습니다.  
    단, 이때는 해시태그를 제거해야 합니다.

12. **The hashtag is just important to create that variable.**  
    **You use it when you add it on the elements**  
    **that should be stored in the variable.**  
    해시태그는 변수를 생성할 때만 중요합니다.  
    변수에 저장할 요소에 해시태그를 추가합니다.

13. **If you then refer to that element anywhere in your template,**  
    **you use the variable name without the hashtag,**  
    **like I'm doing it here.**  
    이후 템플릿에서 해당 요소를 참조할 때는  
    해시태그 없이 변수 이름만 사용하면 됩니다.  
    여기에서 제가 한 것처럼요.

14. **So with that, this input element will be passed**  
    **as an argument to `onSubmit`.**  
    따라서 이 input 요소가 `onSubmit` 메서드의  
    인수로 전달됩니다.

15. **So to get a better understanding**  
    **of what exactly is stored in that `titleInput` thing here,**  
    **let's go to `onSubmit`**  
    **and there, let's accept an argument, a parameter,**  
    **which I'll name `titleElement`, the name is up to you though.**  
    `titleInput` 변수에 정확히 무엇이 저장되어 있는지  
    더 잘 이해하기 위해,  
    `onSubmit` 메서드로 이동하여 인수(파라미터)를  
    받아 보겠습니다.  
    이 파라미터 이름은 `titleElement`로 하겠습니다만,  
    이는 임의로 정할 수 있습니다.

16. **And let's set a type for this parameter**  
    **because since we're using TypeScript,**  
    **we need to let TypeScript know**  
    **which kind of value will be received through that parameter.**  
    그리고 TypeScript를 사용하고 있으므로,  
    이 파라미터에 어떤 값이 전달될지  
    TypeScript에 알려주기 위해 타입을 설정해야 합니다.

17. **Hence you must add a colon here**  
    **and then tell TypeScript which type of element that is.**  
    따라서 여기에 콜론을 추가하고,  
    해당 요소의 타입을 TypeScript에 알려야 합니다.

18. **And we can see which type of element it is**  
    **if we go back to the template**  
    **and we hover over `titleInput`.**  
    템플릿으로 돌아가 `titleInput` 위에 마우스를 올리면,  
    해당 요소의 타입을 확인할 수 있습니다.

19. **Here you see that it's of type `HTMLInputElement`,**  
    **which is a type that's built into TypeScript in the end.**  
    여기에서 이 요소가 `HTMLInputElement` 타입임을  
    알 수 있습니다.  
    이는 TypeScript에 내장된 타입입니다.

20. **It is a type that describes the underlying DOM object**  
    **of such an input element.**  
    이는 해당 input 요소의 기본 DOM 객체를  
    설명하는 타입입니다.

21. **So the type here should also be `HTMLInputElement`,**  
    **written like this.**  
    따라서 여기에서도 타입을 `HTMLInputElement`로  
    작성해야 합니다.

22. **Make sure you get the casing right,**  
    **otherwise you'll get an error.**  
    대소문자를 정확히 입력해야 하며,  
    그렇지 않으면 오류가 발생합니다.

23. **Well, and with that, we can,**  
    **of course, log this `titleElement` here**  
    **to see what's inside it.**  
    이제 `titleElement`를 로그로 출력하여  
    내부에 무엇이 있는지 확인할 수 있습니다.

24. **So if I do all that and I save it all,**  
    **if I again click submit here,**  
    **you will see that the input here is logged like this.**  
    이를 모두 수행하고 저장한 후,  
    다시 "Submit" 버튼을 클릭하면,  
    input 요소가 이렇게 로그로 출력되는 것을 볼 수 있습니다.

25. **Now, that's a bit hard to analyze**  
    **because for convenience reasons,**  
    **the Chrome dev tools actually output that element**  
    **as an HTML element here.**  
    하지만 이를 분석하기는 조금 어렵습니다.  
    Chrome 개발자 도구가 편의상 해당 요소를  
    HTML 요소로 출력하기 때문입니다.

26. **But actually what we get is an object,**  
    **a JavaScript object,**  
    **and the Chrome dev tools will output it as an object instead**  
    **of giving you that convenience**  
    **if you use `console.dir` instead of `console.log`.**  
    하지만 실제로 우리가 얻는 것은  
    JavaScript 객체입니다.  
    `console.log` 대신 `console.dir`을 사용하면,  
    Chrome 개발자 도구는 이를 객체로 출력합니다.

27. **With that used, if you now click submit,**  
    **you will get an object,**  
    **which you can expand,**  
    **and you then see all the properties**  
    **that exist on this object.**  
    이를 사용하여 "Submit" 버튼을 클릭하면,  
    객체가 출력되고, 이를 확장하여  
    객체에 포함된 모든 속성을 확인할 수 있습니다.

28. **And these are all default properties that are set**  
    **and controlled by the browser**  
    **because we're accessing the default DOM object in the end,**  
    **the default object that is created by the browser**  
    **behind the scenes for that input element.**  
    이 속성들은 모두 브라우저에서 설정되고  
    제어되는 기본 속성들입니다.  
    결국 우리는 브라우저가 input 요소를 위해  
    백그라운드에서 생성한 기본 DOM 객체에 접근하는 것입니다.

29. **So this has nothing to do with TypeScript,**  
    **nothing to do with Angular.**  
    이는 TypeScript나 Angular와는 관련이 없습니다.

30. **You could get hold of that object**  
    **with just vanilla JavaScript as well.**  
    이 객체는 순수 JavaScript로도 가져올 수 있습니다.

31. **Of course, not by using**  
    **that template variable syntax here though,**  
    **that is Angular specific,**  
    **but the object that is yielded**  
    **by this syntax is the standard browser input DOM object.**  
    물론 Angular 전용 템플릿 변수 문법을 사용하지는 못하지만,  
    이 문법으로 생성된 객체는  
    표준 브라우저 input DOM 객체입니다.

32. **That's just important to understand.**  
    이는 이해하는 것이 중요합니다.

33. **And you can learn more about that default object**  
    **and which methods and properties exist on it**  
    **and what they're all about**  
    **if you, for example, visit the official MDN article**  
    **for `HTMLInputElement`.**  
    기본 객체와 그 객체의 메서드 및 속성,  
    그리고 해당 기능에 대해 더 알고 싶다면,  
    MDN의 `HTMLInputElement` 공식 문서를  
    참고할 수 있습니다.

34. **You find a link to it attached.**  
    이에 대한 링크는 첨부되어 있습니다.

35. **Now, one piece of data we can extract**  
    **from that object is the `value` property.**  
    이 객체에서 추출할 수 있는 데이터 중 하나는  
    `value` 속성입니다.

36. **If you scroll down here, you will find a `value` property.**  
    아래로 스크롤하면 `value` 속성을 확인할 수 있습니다.

37. **And that's interesting because if I reload here**  
    **and I enter something here**  
    **and I click submit, you will see that now if I scroll down**  
    **to that `value` property,**  
    **the entered text is stored in there**  
    **and that would be an alternative way of extracting it.**  
    이 점이 흥미로운 이유는,  
    페이지를 새로고침하고  
    텍스트를 입력한 뒤 "Submit" 버튼을 클릭하면,  
    `value` 속성을 확인했을 때,  
    입력한 텍스트가 저장되어 있다는 것을 알 수 있기 때문입니다.  
    이는 값을 추출하는 또 다른 방법이 될 수 있습니다.

38. **So if I wanted to get the `enteredTitle`, I could get it**  
    **by accessing `titleElement.value` like this,**  
    **and then I can log the entered title like that, for example.**  
    따라서 `enteredTitle` 값을 얻고 싶다면,  
    `titleElement.value`를 통해 접근할 수 있습니다.  
    그런 다음, 이를 로그로 출력할 수도 있습니다.

39. **If I do that and save that all,**  
    **if I again enter `test` here**  
    **and click submit, you see that is being output**  
    **and that would be an alternative way**  
    **of extracting the entered value.**  
    이를 수행하고 저장한 후,  
    다시 "test"를 입력하고 "Submit" 버튼을 클릭하면,  
    입력한 값이 출력됩니다.  
    이는 입력 값을 추출하는 또 다른 대안입니다.

40. **Is it better than using two-way binding?**  
    **Not necessarily, though it might be**  
    **because it does not update some value**  
    **on every keystroke behind the scenes.**  
    양방향 바인딩보다 나을까요?  
    꼭 그렇지는 않지만, 경우에 따라  
    더 나을 수 있습니다.  
    이는 키 입력마다 값이 업데이트되지 않기 때문입니다.

41. **But most importantly, it's simply an alternative,**  
    **an alternative you'll see in some projects**  
    **and therefore, an alternative you should be aware of.**  
    하지만 가장 중요한 점은,  
    이것이 단순히 대안일 뿐이라는 것입니다.  
    일부 프로젝트에서 이러한 방식을 사용하므로,  
    이를 알고 있어야 합니다.

42. **Because, of course, this is an absolutely fine way**  
    **of getting hold of the entered input value.**  
    왜냐하면, 입력 값을 가져오는  
    완전히 괜찮은 방법이기 때문입니다.

---

끝났습니다.
