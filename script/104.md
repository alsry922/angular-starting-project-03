1. **So here I want to extend the built-in button.component.**  
   여기서는 기본 제공되는 `button.component`를 확장하려고 합니다.

2. **And as mentioned, if that's the case,**  
   **if you wanna essentially extend a built-in component,**  
   **you can do that in a slightly different way**  
   **than you did it before.**  
   기본 컴포넌트를 확장하려는 경우,  
   이전과는 약간 다른 방식으로 이를 수행할 수 있습니다.

3. **Instead of putting that button element here**  
   **into the template of our button.component,**  
   **we could focus on just having the actual content**  
   **of the button in here.**  
   버튼 요소를 `button.component`의 템플릿에 추가하는 대신,  
   버튼의 실제 콘텐츠에만 집중할 수 있습니다.

4. **And we could then go to the button.component TypeScript file**  
   **and change the selector.**  
   그런 다음, `button.component`의 TypeScript 파일로 이동해  
   셀렉터를 변경할 수 있습니다.

5. **Because this selector here is not restricted**  
   **to being an element selector as we have it here**  
   **and as we had it in all our other components thus far.**  
   이 셀렉터는 지금까지 다른 컴포넌트에서 사용했던  
   요소 셀렉터에 국한되지 않습니다.

6. **Indeed, it's the most common case,**  
   **and it's typically the best choice**  
   **to have an element selector like this,**  
   **but you're not limited to that.**  
   실제로 요소 셀렉터가 가장 일반적이며  
   일반적으로 최선의 선택이지만,  
   반드시 그렇게 해야 하는 것은 아닙니다.

7. **Instead, Angular supports other kinds of selectors as well.**  
   대신, Angular는 다른 유형의 셀렉터도 지원합니다.

8. **And attached, you find a link**  
   **to the official documentation about component selectors**  
   **where you can learn all about the different kinds**  
   **of selectors that could be used with Angular components.**  
   첨부된 링크를 통해  
   Angular 컴포넌트 셀렉터에 대한 공식 문서를 확인할 수 있으며,  
   다양한 유형의 셀렉터에 대해 배울 수 있습니다.

---

계속 이어가겠습니다.

9. **And one kind of selector you could use**  
   **is an attribute selector instead of an element selector.**  
   사용할 수 있는 셀렉터 중 하나는  
   요소 셀렉터 대신 속성 셀렉터(attribute selector)입니다.

10. **An element selector is always defined**  
    **by just putting the element name here, like button**  
    **or typically prefixed with app-.**  
    요소 셀렉터는 항상  
    요소 이름(예: `button`)을 사용하여 정의되며,  
    일반적으로 `app-` 접두사를 붙입니다.

11. **An attribute selector, on the other hand, is defined**  
    **by using square brackets here, which has nothing to do**  
    **with property binding or anything like that in this place.**  
    반면, 속성 셀렉터는 대괄호(`[]`)를 사용하여 정의되며,  
    여기서는 프로퍼티 바인딩과는 관련이 없습니다.

12. **Instead, this is just how in CSS you would set up**  
    **an attribute selector**  
    **and the component selector from @Component works**  
    **like a CSS selector.**  
    대신, 이는 CSS에서 속성 셀렉터를 설정하는 방법과 같으며,  
    `@Component`의 컴포넌트 셀렉터도  
    CSS 셀렉터처럼 작동합니다.

13. **And then you can set up any attribute**  
    **of your choice like appButton,**  
    **which, of course, isn't a built-in attribute,**  
    **but now whenever you would add that attribute to an element,**  
    **this component would become active**  
    **and would effectively replace it or take control of it.**  
    그런 다음, `appButton`과 같은 원하는 속성을 설정할 수 있습니다.  
    이는 기본 제공 속성이 아니지만,  
    이 속성을 요소에 추가하면  
    컴포넌트가 활성화되며 해당 요소를 효과적으로 대체하거나  
    제어하게 됩니다.

14. **And you can even combine that with other selectors.**  
    **For example, if I write button[appButton],**  
    **I am telling Angular**  
    **that any button element anywhere in my application**  
    **that also has the appButton attribute on it**  
    **should be controlled by this component.**  
    다른 셀렉터와 결합할 수도 있습니다.  
    예를 들어, `button[appButton]`을 작성하면  
    애플리케이션 내의 모든 `button` 요소 중  
    `appButton` 속성을 가진 요소를  
    이 컴포넌트가 제어하도록 Angular에 지시하는 것입니다.

---

계속 이어가겠습니다.

15. **Besides the attribute selector,**  
    **you can, by the way, also, for example,**  
    **use a CSS class selector by adding a dot at the beginning,**  
    **and you can also combine that to control buttons**  
    **that have a class of button on them.**  
    속성 셀렉터 외에도,  
    예를 들어 CSS 클래스 셀렉터를 사용할 수 있습니다.  
    클래스 이름 앞에 점(`.`)을 추가하여  
    `button` 클래스를 가진 버튼을 제어하도록  
    셀렉터를 결합할 수도 있습니다.

16. **But here I wanna control buttons**  
    **that have the attribute appButton on them,**  
    **and it's considered a good practice**  
    **to prefix your custom attributes that are meant**  
    **to be used by Angular with your application prefix.**  
    여기서는 `appButton` 속성을 가진 버튼을  
    제어하려고 합니다.  
    Angular에서 사용할 커스텀 속성에  
    애플리케이션 접두사를 추가하는 것은  
    좋은 관행으로 간주됩니다.

17. **So the same prefix you, for example, used**  
    **for all your components.**  
    이는 모든 컴포넌트에서 사용했던  
    동일한 접두사를 적용하는 것입니다.

18. **And that's therefore now the selector I wanna have here**  
    **for this button.component to extend that built-in button.**  
    따라서 이 `button.component`에서  
    기본 버튼을 확장하기 위해  
    사용할 셀렉터가 바로 이것입니다.

19. **Now, if I now wanna use that component, for example,**  
    **in the header.component, I do that**  
    **by bringing back the regular built-in button,**  
    **but by now also placing appButton as an attribute on it**  
    **or whichever attribute you chose in your component selector.**  
    예를 들어, 이 컴포넌트를  
    `header.component`에서 사용하려면,  
    기본 제공 버튼을 그대로 두고  
    `appButton` 속성을 추가하여  
    컴포넌트를 활성화하면 됩니다.  
    또는 컴포넌트 셀렉터에 정의한  
    다른 속성을 사용할 수도 있습니다.

---

계속 이어가겠습니다.

20. **Now, I don't need to enter anything**  
    **between the button tags here**  
    **because right now, here in this application,**  
    **I have all the content**  
    **that should be output here in the button component template,**  
    **and it is that template that will now be rendered by Angular**  
    **for this button component.**  
    이제 버튼 태그 사이에  
    아무것도 입력할 필요가 없습니다.  
    현재 애플리케이션에서는  
    버튼 컴포넌트 템플릿에 출력될  
    모든 콘텐츠가 포함되어 있으며,  
    Angular는 이 템플릿을 렌더링할 것입니다.

21. **Because we are now taking control**  
    **of this built-in button with our custom component.**  
    이는 우리가 기본 버튼을  
    커스텀 컴포넌트로 제어하고 있기 때문입니다.

22. **And that can be a pretty powerful Angular feature**  
    **and pattern because it essentially allows you**  
    **to use built-in elements**  
    **and extend their functionality or templates.**  
    이는 매우 강력한 Angular 기능과 패턴으로,  
    기본 요소를 사용하면서  
    그 기능이나 템플릿을 확장할 수 있게 해줍니다.

23. **So with that, if I now saved it**  
    **and I reload, I still have my logout button here,**  
    **but if we now inspect that, you see**  
    **that now the app-button wrapper around it is gone,**  
    **and instead now it's the built-in button**  
    **that's being rendered, but our template is then rendered**  
    **inside of it,**  
    **and that saves us this extra unnecessary DOM element**  
    **that we had in the DOM before.**  
    이렇게 저장하고 새로고침하면  
    여전히 로그아웃 버튼이 표시됩니다.  
    그러나 이를 검사해보면,  
    이전에 있던 `app-button` 래퍼는 사라지고,  
    대신 기본 버튼이 렌더링됩니다.  
    그리고 우리의 템플릿은 그 내부에 렌더링되며,  
    이를 통해 이전에 DOM에 있던  
    불필요한 요소를 제거할 수 있습니다.

24. **Now, you could use that on other components as well,**  
    **but typically, this pattern of selecting an element**  
    **by attribute is used if you wanna extend a built-in element.**  
    이 방식을 다른 컴포넌트에도 적용할 수 있지만,  
    일반적으로 속성 셀렉터를 사용하는 패턴은  
    기본 요소를 확장하고자 할 때 사용됩니다.

25. **Whenever you're building a brand new component**  
    **that just wraps a bunch of built-in elements**  
    **but doesn't really replace one,**  
    **you should use the element selector as we did it before.**  
    여러 기본 요소를 감싸지만  
    실제로 이를 대체하지 않는  
    새로운 컴포넌트를 만들 때는  
    이전에 사용했던 요소 셀렉터를 사용하는 것이 좋습니다.

26. **So that should be your default,**  
    **but knowing about this kind of selector**  
    **and that you can do that with Angular is important.**  
    따라서 요소 셀렉터를 기본으로 사용하되,  
    이러한 유형의 셀렉터와  
    Angular에서 이를 사용할 수 있다는 점을  
    알고 있는 것이 중요합니다.

---

**번역이 완료되었습니다.**
