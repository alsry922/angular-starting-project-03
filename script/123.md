1. Now, as you can tell,  
   if you take a look at the official documentation,  
   Angular got quite a few Lifecycle Hooks,  
   quite a few methods you can add to your Component classes  
   to have them triggered by Angular.  
   이제 공식 문서를 보면,  
   Angular에는 다양한 생명주기 훅(Lifecycle Hooks)과  
   컴포넌트 클래스에 추가하여 Angular에서 호출할 수 있는  
   여러 메서드가 있음을 알 수 있습니다.

2. And in that documentation at the bottom of that page,  
   which you also find attached to this lecture,  
   you also find some nice diagrams that show you the order  
   in which those Lifecycle Hook methods are invoked.  
   강의와 함께 제공된 문서 하단에는  
   생명주기 훅 메서드가 호출되는 순서를 보여주는  
   유용한 다이어그램도 있습니다.

3. Depending on whether a Component  
   is rendered for the first time  
   or if it is just updated because some input data changed.  
   컴포넌트가 처음 렌더링되었는지  
   아니면 입력 데이터가 변경되어  
   업데이트되었는지에 따라 호출 순서가 다릅니다.

4. But the best way to understand this order  
   is to see it in Action.  
   하지만 이러한 순서를 이해하는 가장 좋은 방법은  
   실제 실행을 통해 확인하는 것입니다.

5. That's why I prepared a brand-new project,  
   and we'll get back to our main project thereafter.  
   그래서 저는 새 프로젝트를 준비했고,  
   이후에 메인 프로젝트로 돌아가겠습니다.

6. But I prepared this project,  
   if you want to call it like this,  
   because this is a demo project  
   where I have one simple `LifecycleComponent`  
   where I just output some dummy text  
   which implements all these lifecycle interfaces,  
   and therefore all these lifecycle methods.  
   이 데모 프로젝트는 간단한 `LifecycleComponent`를 포함하며,  
   해당 컴포넌트는 더미 텍스트를 출력하고,  
   모든 생명주기 인터페이스와 메서드를 구현합니다.

7. And then in there I simply log to the console  
   because that of course is a great way of seeing  
   in which order these hooks are executed  
   and when exactly these hook methods are executed.  
   그런 다음, 콘솔에 로그를 출력하여  
   이 훅이 어떤 순서로 실행되는지  
   그리고 정확히 언제 실행되는지 확인합니다.

8. Now, you find this project attached,  
   and you can of course then download it, run `npm install`,  
   and then `npm start` to start it.  
   이 프로젝트는 강의 자료로 제공되며,  
   다운로드 후 `npm install`과 `npm start`를 실행하여  
   시작할 수 있습니다.

9. And if you do so, you should see this screen here.  
   그렇게 하면 이 화면이 표시될 것입니다.

10. And there you can toggle the `LifecycleComponent` visibility  
    so that this Component appears or disappears.  
    여기에서 `LifecycleComponent`의 가시성을 전환하여  
    컴포넌트가 나타나거나 사라지게 할 수 있습니다.

11. And you can also change the `LifecycleComponent` text  
    so that this text down here,  
    and therefore mostly this number here will change  
    every time you click this button.  
    또한, `LifecycleComponent` 텍스트를 변경하여  
    버튼을 클릭할 때마다 텍스트와 숫자가 변경됩니다.

12. And that's all happening  
    due to how this `LifecycleComponent` is built,  
    that it receives an input.  
    이는 `LifecycleComponent`가  
    입력 값을 받도록 설계되었기 때문에 발생합니다.

13. And that in the `AppComponent`,  
    I'm then rendering it conditionally based  
    on that `LifecycleComponent` is visible,  
    State property here,  
    which is updated whenever this first button  
    is clicked here in this  
    `onToggleLifecycleComponentVisibility` method.  
    그리고 `AppComponent`에서는  
    `LifecycleComponent`가 표시될지 여부를  
    조건적으로 렌더링하며,  
    이 상태 속성은  
    `onToggleLifecycleComponentVisibility` 메서드에서  
    첫 번째 버튼이 클릭될 때 업데이트됩니다.

14. Now, therefore in this application,  
    if you open your browser developer tools,  
    you'll see a bunch of logs.  
    이 애플리케이션에서 브라우저 개발자 도구를 열면  
    로그가 많이 출력되는 것을 볼 수 있습니다.

15. And I'll reload this to clear my logs,  
    and you'll now see that if you click  
    on toggle LifecycleComponent visibility  
    to show this Component for the first time,  
    these are the logs that are being output.  
    로그를 지우고 새로고침한 후  
    `toggle LifecycleComponent visibility` 버튼을 클릭하면,  
    처음으로 이 컴포넌트를 표시할 때 출력되는  
    로그를 확인할 수 있습니다.

16. And here we also see the order  
    in which these different lifecycle methods are executed.  
    여기에서 다양한 생명주기 메서드가  
    실행되는 순서를 볼 수 있습니다.

17. It's also worth noting  
    that for the `ngOnChanges` Lifecycle Hook,  
    I'm also logging an argument that is received  
    by that Lifecycle Hook.  
    `ngOnChanges` 생명주기 훅에서는  
    해당 훅이 받는 인수를 로그로 기록하고 있습니다.

18. This changes object which will be passed  
    into this lifecycle method automatically by Angular,  
    because all these different hooks,  
    of course, have different purposes.  
    이 `changes` 객체는 Angular에 의해  
    생명주기 메서드로 자동 전달되며,  
    각 훅은 서로 다른 목적을 가지고 있습니다.

19. And I'll get back to those purposes in just a second.  
    이 훅들의 목적에 대해서는 곧 설명하겠습니다.

20. This `ngOnChanges` hook, for example,  
    is executed by Angular whenever the input that is received,  
    or the inputs if it's multiple inputs, that are received change.  
    예를 들어, `ngOnChanges` 훅은  
    Angular가 입력 값을 받을 때,  
    또는 여러 입력 값 중 하나라도 변경될 때 실행됩니다.

21. So in this case, whenever this text input changes.  
    따라서 이 경우, 텍스트 입력 값이 변경될 때마다 실행됩니다.

22. And Angular then automatically produces a `changes` object,  
    which gives you more information  
    about the input changes that happened.  
    그리고 Angular는 자동으로 `changes` 객체를 생성하여  
    입력 변경 사항에 대한 추가 정보를 제공합니다.

23. We can see that here.  
    이를 여기에서 확인할 수 있습니다.

24. If we expand this object,  
    we can see that it contains one property  
    per Component input.  
    객체를 확장하면, 컴포넌트 입력마다  
    하나의 속성이 포함되어 있음을 볼 수 있습니다.

25. And here I only have one input, the text input.  
    여기에서는 텍스트 입력 하나만 존재합니다.

26. That's why in my case here,  
    I only have one property here,  
    the `text` property for this text input.  
    그래서 제 경우에는  
    텍스트 입력에 해당하는 `text` 속성만 존재합니다.

27. And if we expand that,  
    we get some information about that input and how it changed.  
    이를 확장하면 해당 입력 값과 변경 사항에 대한  
    정보를 확인할 수 있습니다.

28. We can see the currently assigned value,  
    so the latest value that was received here,  
    which is that text that's also showing up on the screen.  
    현재 할당된 값, 즉 가장 최근에 받은 값과  
    화면에 표시된 텍스트를 볼 수 있습니다.

29. We also learn whether it's the first change  
    that occurred here.  
    또한, 이것이 처음 발생한 변경인지도 확인할 수 있습니다.

30. So if it's the initial value in the end,  
    and that is the case here.  
    결국 이것이 초기 값이라면,  
    이 경우에 해당합니다.

31. And if it would not be the first change,  
    we would also see the previous value.  
    첫 번째 변경이 아니라면, 이전 값도 확인할 수 있습니다.

32. Or if we had assigned an initial value in the Component,  
    we would see that previous value here as well.  
    또는 컴포넌트에 초기 값을 할당했다면,  
    이전 값도 여기에서 확인할 수 있습니다.

33. And you get this information for all the input properties  
    that you do add to a Component.  
    그리고 컴포넌트에 추가된 모든 입력 속성에 대해  
    이러한 정보를 얻을 수 있습니다.

34. And whilst you might not need that information too often,  
    it can sometimes come in handy  
    if you then have some Component internal state,  
    so some other property in the `LifecycleComponent`  
    which you wanna change whenever the input value changes.  
    이러한 정보가 자주 필요하지는 않을 수 있지만,  
    입력 값이 변경될 때 컴포넌트 내부 상태  
    (예: `LifecycleComponent`의 다른 속성)를  
    변경해야 하는 경우 유용할 수 있습니다.

35. You could then use the `ngOnChanges` hook to do that,  
    because that hook gets triggered whenever the input changes,  
    so you could then calculate  
    some new Component internal state based on that  
    and based on the changes information you're getting here,  
    for example.  
    이때 `ngOnChanges` 훅을 사용하여  
    입력 값이 변경될 때마다 트리거되도록 설정하고,  
    변경 정보를 기반으로 새로운 컴포넌트 내부 상태를  
    계산할 수 있습니다.

36. But that's the `ngOnChanges` hook.  
    이것이 `ngOnChanges` 훅입니다.

37. As you see, there also are some other hooks  
    that are executed in this order.  
    보시다시피, 이 순서로 실행되는  
    다른 훅들도 존재합니다.

---

(내용이 많아서 다음 번역으로 이어서 진행하겠습니다.)
