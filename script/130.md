1. **So you did learn quite a bit**  
   **about template variables already,**  
   **and now I wanna build up on that**  
   **and use a template variable to reset that form**  
   **whenever it is submitted.**  
   템플릿 변수에 대해 이미 많은 것을 배웠습니다.  
   이제 이를 확장하여,  
   폼이 제출될 때 템플릿 변수를 사용해  
   폼을 리셋하는 방법을 알아보겠습니다.

2. **And then building up on that,**  
   **I'll show you a different way of getting hold of the value**  
   **that's stored in the template variable,**  
   **but let's start simple.**  
   그 후에는 템플릿 변수에 저장된 값을  
   가져오는 또 다른 방법도 보여드리겠습니다.  
   하지만 먼저 간단한 작업부터 시작하겠습니다.

3. **Let's make sure that we get access to that form**  
   **through a template variable.**  
   템플릿 변수를 통해  
   해당 폼에 접근할 수 있도록 설정해봅시다.

4. **To do that, you can add a template variable**  
   **to the form element,**  
   **and I'll name it `form`,**  
   **but of course the name is up to you.**  
   이를 위해 form 요소에 템플릿 변수를 추가할 수 있습니다.  
   저는 이를 `form`이라 이름 짓겠지만,  
   이름은 자유롭게 정할 수 있습니다.

5. **And if you hover over that,**  
   **you see that it is the DOM element,**  
   **the `HTMLFormElement`,**  
   **the object that is created behind the scenes**  
   **for this form here that is stored in this template variable.**  
   `form` 위에 마우스를 올리면,  
   이는 DOM 요소인 `HTMLFormElement`임을 알 수 있습니다.  
   이 객체는 해당 폼을 위해 백그라운드에서  
   생성되어 템플릿 변수에 저장됩니다.

6. **Therefore, if I wanna reset that form**  
   **whenever the form is submitted,**  
   **I could pass that form template variable as a third argument**  
   **to `onSubmit`.**  
   따라서 폼이 제출될 때 폼을 리셋하려면,  
   템플릿 변수 `form`을  
   `onSubmit`의 세 번째 인수로 전달할 수 있습니다.

7. **And in the `onSubmit` method, I now just have to accept it,**  
   **and accept a `form` parameter,**  
   **which is of type `HTMLFormElement`.**  
   그런 다음, `onSubmit` 메서드에서  
   이를 `HTMLFormElement` 타입의 `form` 매개변수로  
   받아야 합니다.

8. **And then we could use this `form` parameter**  
   **to call the built-in `reset` method**  
   **on that `HTMLFormElement` object.**  
   이제 이 `form` 매개변수를 사용해  
   해당 `HTMLFormElement` 객체에서  
   내장된 `reset` 메서드를 호출할 수 있습니다.

9. **Because the object that's automatically constructed**  
   **by the browser in the end for this form element**  
   **does have such a `reset` method,**  
   **which does what the name implies.**  
   브라우저가 폼 요소를 위해  
   자동으로 생성하는 객체에는  
   이름 그대로 동작하는 `reset` 메서드가 포함되어 있습니다.

10. **It clears all the input elements**  
    **that are inside of that form.**  
    이는 해당 폼 내부의 모든 입력 요소를 초기화합니다.

11. **So in this case, this input and this textarea.**  
    따라서 이 경우, input과 textarea가 초기화됩니다.

12. **Therefore with this code,**  
    **if I save that and I go back to my application,**  
    **if I enter something here and I click submit,**  
    **you see those inputs are cleared thereafter**  
    **and that happens because of `form.reset`.**  
    따라서 이 코드를 저장하고 애플리케이션으로 돌아가  
    값을 입력한 후 "Submit" 버튼을 클릭하면,  
    입력 필드가 초기화됩니다.  
    이는 `form.reset` 때문에 발생합니다.

13. **Now that's nice to know,**  
    **but that's not the main thing I want to show you here.**  
    이 방법을 아는 것은 좋지만,  
    여기서 보여드리고자 하는 주요 내용은 아닙니다.

14. **Instead, it would be nice if we could add**  
    **that template variable here**  
    **and then get hold of it inside**  
    **of that `NewTicketComponent`**  
    **without passing it as an argument to `onSubmit`.**  
    대신, 템플릿 변수로 설정된 요소를  
    `onSubmit` 메서드의 인수로 전달하지 않고도  
    `NewTicketComponent` 내부에서  
    이를 참조할 수 있으면 좋겠습니다.

15. **So that we don't have to pass all the things we wanna use**  
    **in `onSubmit` as an argument to it.**  
    이렇게 하면, `onSubmit`에서 사용할 모든 항목을  
    인수로 전달할 필요가 없어집니다.

16. **Of course we can do that,**  
    **but I wanna show you an alternative,**  
    **and that alternative can especially be helpful**  
    **if you wanna access an element that has a template variable**  
    **on it in some code that's not triggered because of an event,**  
    **so where you can't pass the template variable easily**  
    **as an argument to some method.**  
    물론, 이를 구현할 수 있지만,  
    다른 방법을 보여드리겠습니다.  
    특히, 이벤트로 인해 트리거되지 않은 코드에서  
    템플릿 변수가 설정된 요소에 접근해야 할 때  
    유용한 대안입니다.  
    이 경우, 템플릿 변수를 메서드의 인수로  
    쉽게 전달할 수 없습니다.

17. **So to simulate that here,**  
    **I'll remove `form` as an argument from `onSubmit`**  
    **and I no longer expect to get it here as a parameter.**  
    이를 시뮬레이션하기 위해,  
    `onSubmit`에서 `form`을 인수로 전달하지 않으며,  
    이를 파라미터로 기대하지 않겠습니다.

18. **And therefore of course here,**  
    **`form` now is undefined**  
    **or can't be found by JavaScript in the end**  
    **because there is no variable called `form` available here.**  
    따라서 여기에서 `form`은 undefined 상태가 되며,  
    JavaScript에서 이를 찾을 수 없습니다.  
    이 변수는 더 이상 사용할 수 없습니다.

19. **But there now is a different way of getting hold**  
    **of that element in the DOM**  
    **that has this template variable on it.**  
    하지만, 템플릿 변수가 설정된  
    DOM 요소에 접근할 수 있는  
    또 다른 방법이 있습니다.

20. **We can get hold of it by adding a new property**  
    **to this component.**  
    **For example, a property called `form`,**  
    **but the name is up to you of course,**  
    **and by then decorating this property**  
    **with the `ViewChild` decorator,**  
    **which must be imported from `@angular/core`.**  
    컴포넌트에 새 속성을 추가하여  
    해당 요소에 접근할 수 있습니다.  
    예를 들어, 속성 이름을 `form`으로 지정할 수 있지만,  
    이름은 자유롭게 정할 수 있습니다.  
    그리고 이 속성을 `@angular/core`에서 가져온  
    `ViewChild` 데코레이터로 장식합니다.

21. **Now the `ViewChild` decorator is a decorator that can be used**  
    **to select elements in the template of this component**  
    **and make them available here in this component class.**  
    `ViewChild` 데코레이터는  
    컴포넌트 템플릿 내의 요소를 선택하여  
    이를 컴포넌트 클래스에서 사용할 수 있도록  
    만드는 데 사용됩니다.

22. **`ViewChild` therefore is a decorator**  
    **that helps us find child elements in that component's view,**  
    **so in that component's template.**  
    따라서 `ViewChild`는 컴포넌트 뷰,  
    즉 템플릿 내부의 자식 요소를 찾는 데 도움을 주는  
    데코레이터입니다.

23. **To do that, `ViewChild` needs a selector as an argument**  
    **and that selector can be a string**  
    **and I'll show you what to put into that string**  
    **in just a second.**  
    이를 수행하려면, `ViewChild`에  
    선택자를 인수로 전달해야 합니다.  
    이 선택자는 문자열일 수 있으며,  
    어떤 문자열을 사용해야 하는지  
    곧 설명하겠습니다.

24. **But it could also be the class name**  
    **of one of your components, like `ButtonComponent`,**  
    **for example.**  
    선택자로 컴포넌트 클래스 이름,  
    예를 들어 `ButtonComponent`를 사용할 수도 있습니다.

25. **If you would use such a class name,**  
    **then `ViewChild` would look for an instance**  
    **of your `ButtonComponent` in this template,**  
    **and here it would find one,**  
    **and it would then store that instance**  
    **in that `form` property here.**  
    이렇게 클래스 이름을 사용하면,  
    `ViewChild`는 템플릿에서 `ButtonComponent`의  
    인스턴스를 찾습니다.  
    찾으면, 이를 `form` 속성에 저장합니다.

26. **So then you could interact**  
    **with that `ButtonComponent` instance**  
    **via that property in this component class.**  
    이렇게 하면, 컴포넌트 클래스의 해당 속성을 통해  
    `ButtonComponent` 인스턴스와 상호작용할 수 있습니다.

27. **And that can sometimes be useful.**  
    이는 때때로 매우 유용할 수 있습니다.

28. **You can also not just pass component classes here,**  
    **but also classes of directives,**  
    **but that's not something we need to do here.**  
    컴포넌트 클래스뿐만 아니라,  
    디렉티브 클래스도 선택자로 전달할 수 있습니다.  
    하지만 여기서는 필요하지 않습니다.

29. **Instead, another pretty powerful way of using `ViewChild`**  
    **is to pass a string to it**  
    **and as a string value,**  
    **you pass one of your template variable names.**  
    대신, `ViewChild`를 사용하는  
    또 다른 강력한 방법은 문자열을 전달하는 것입니다.  
    이 문자열 값으로 템플릿 변수 이름을 전달합니다.

30. **So for example, `form`,**  
    **you can't pass a CSS selector here,**  
    **so something like that won't work.**  
    예를 들어 `form`이라는 이름을 사용할 수 있습니다.  
    하지만 CSS 선택자는 전달할 수 없습니다.  
    따라서 그런 방식은 동작하지 않습니다.

31. **You can't select elements by CSS class,**  
    **but you can pass the name of a template variable.**  
    CSS 클래스 이름으로 요소를 선택할 수는 없지만,  
    템플릿 변수 이름은 전달할 수 있습니다.

32. **So by passing `form` here without the hashtag,**  
    **I'm telling Angular that it should look for an element**  
    **with a template variable called `form` on it,**  
    **and then it should store the value that's stored**  
    **in that template variable**  
    **or the value of the element**  
    **on which this template variable is placed,**  
    **therefore in that property here.**  
    해시태그 없이 `form`을 전달하면,  
    Angular는 템플릿 변수 이름이 `form`인 요소를 찾습니다.  
    그런 다음, 해당 템플릿 변수에 저장된 값  
    또는 해당 요소 자체를 속성에 저장합니다.

33. **That's how that works.**  
    이것이 동작하는 방식입니다.

34. **With that, you then just have to tell TypeScript**  
    **which type of value will actually be stored**  
    **in that property,**  
    **and that would be an `ElementRef`.**  
    그런 다음 TypeScript에  
    해당 속성에 실제로 저장될 값의 타입을  
    알려줘야 합니다.  
    이 타입은 `ElementRef`가 됩니다.

35. **So you must import `ElementRef` from `@angular/core`**  
    **and use that as a type for this property.**  
    따라서 `@angular/core`에서 `ElementRef`를 가져와  
    이 속성의 타입으로 사용해야 합니다.

36. **Now the `ElementRef` type just defines the type**  
    **for a wrapper object though.**  
    **Because Angular in the end will wrap the element it finds**  
    **with help of that selector in such an `ElementRef` object.**  
    `ElementRef` 타입은 래퍼 객체의 타입을 정의합니다.  
    Angular는 선택자를 사용해 찾은 요소를  
    `ElementRef` 객체로 감쌉니다.

37. **And that's why `ElementRef` is actually a generic type**  
    **that needs extra information about the type of value**  
    **that will be wrapped by it here when using `ViewChild`.**  
    그래서 `ElementRef`는 제네릭 타입이며,  
    `ViewChild`를 사용할 때  
    이 객체가 감쌀 값의 타입에 대한  
    추가 정보를 제공해야 합니다.

38. **So you give it that extra information**  
    **by adding angle brackets here,**  
    **and then between those angle brackets,**  
    **you define the type of value**  
    **that will be wrapped by `ElementRef`.**  
    추가 정보를 제공하려면  
    꺾쇠 괄호(`< >`)를 사용하고,  
    그 안에 `ElementRef`가 감쌀 값의 타입을 정의합니다.

39. **Which will be the type of value**  
    **that will be selected by that selector,**  
    **so the type of element that will be selected by it.**  
    이는 선택자로 선택된 값의 타입,  
    즉 선택된 요소의 타입이 됩니다.

40. **And here in this case,**  
    **that will be an `HTMLFormElement`,**  
    **so that is the type that should go**  
    **between these angle brackets.**  
    여기서는 `HTMLFormElement`가 해당 타입이며,  
    이 타입을 꺾쇠 괄호 안에 지정해야 합니다.

41. **Last but not least, you should add a question mark here**  
    **because this property here**  
    **will not immediately be populated with a value.**  
    마지막으로, 해당 속성에  
    물음표(`?`)를 추가해야 합니다.  
    이 속성은 즉시 값이 할당되지 않기 때문입니다.

42. **Instead, when this component class here is instantiated,**  
    **no template will exist yet**  
    **because Angular won't have initialized it yet.**  
    컴포넌트 클래스가 인스턴스화될 때,  
    템플릿은 아직 존재하지 않습니다.  
    Angular가 이를 초기화하지 않았기 때문입니다.

43. **And therefore initially,**  
    **this will indeed be `undefined`**  
    **and it will only be populated**  
    **with the value once Angular has initialized the template.**  
    따라서 초기에는 이 속성이 `undefined` 상태이며,  
    Angular가 템플릿을 초기화한 후에만 값이 할당됩니다.

44. **That's why for example in the constructor,**  
    **you would not be able to access this form element yet,**  
    **but that's no problem because we need access**  
    **to it here in `onSubmit`.**  
    그래서 생성자에서 이 폼 요소에  
    접근할 수 없습니다.  
    하지만 `onSubmit`에서 필요하므로 문제는 없습니다.

45. **And we can now get access here by using `this.form`,**  
    **so by using this property.**  
    이제 `this.form` 속성을 사용하여  
    이 폼 요소에 접근할 수 있습니다.

46. **And now we just need to convince TypeScript**  
    **that this will be defined so that it will not be undefined.**  
    그리고 TypeScript에  
    이 속성이 정의될 것임을 알려  
    `undefined` 오류를 방지해야 합니다.

47. **And you can do that by adding a question mark here**  
    **which tells TypeScript that it should only try**  
    **to access the `reset` method if this here is not undefined,**  
    **otherwise it will not continue**  
    **so that it won't generate a runtime error.**  
    물음표(`?`)를 추가하면,  
    TypeScript에 `reset` 메서드 접근은  
    이 속성이 `undefined`가 아닌 경우에만 시도하도록  
    설정할 수 있습니다.  
    그렇지 않으면 실행 시 오류가 발생하지 않습니다.

48. **Now I'm still getting an error here though**  
    **that `reset` does not exist on the type**  
    **because inside of the `form`,**  
    **we stored that `ElementRef` object, not the `HTMLFormElement`.**  
    하지만 여기서 여전히 오류가 발생합니다.  
    `reset` 메서드가 해당 타입에 존재하지 않는다는 오류인데,  
    이는 `form` 속성 안에 저장된 것이  
    `HTMLFormElement`가 아니라  
    `ElementRef` 객체이기 때문입니다.

49. **Instead, that is wrapped by this `ElementRef` object.**  
    이는 `ElementRef` 객체로 감싸져 있습니다.

50. **So we first need to access the `nativeElement` property**  
    **on that `ElementRef` wrapper object,**  
    **and that will then be that `HTMLFormElement`,**  
    **so there we can then call `reset`.**  
    따라서 먼저 `ElementRef` 래퍼 객체의  
    `nativeElement` 속성에 접근해야 합니다.  
    그러면 `HTMLFormElement`에 접근할 수 있으며,  
    이를 통해 `reset` 메서드를 호출할 수 있습니다.

51. **And that's therefore a different way of getting hold**  
    **of an element that is stored in the template inside**  
    **of this component class here**  
    **with help of the `ViewChild` decorator.**  
    이것은 `ViewChild` 데코레이터를 사용하여  
    템플릿 내부의 요소를 컴포넌트 클래스에서  
    참조할 수 있는 또 다른 방법입니다.

52. **With that, if you save everything and you reload,**  
    **you'll see that if you submit the form,**  
    **it is still reset as it was before.**  
    이를 저장하고 애플리케이션을 새로고침한 후,  
    폼을 제출하면 이전처럼 폼이 리셋되는 것을  
    확인할 수 있습니다.

---

끝났습니다.
