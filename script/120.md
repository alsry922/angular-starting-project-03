1. So we got this `ServerStatusComponent`,  
   but at the moment the status never changes.  
   현재 우리는 `ServerStatusComponent`를 가지고 있지만,  
   상태는 변경되지 않고 있습니다.

2. Of course, in this demo application,  
   we are not actually grabbing that server status  
   from any real servers,  
   but I wanna simulate that it changes every couple of seconds  
   to some random value,  
   so either to `offline`, `online`, or `unknown`.  
   물론, 이 데모 애플리케이션에서는  
   실제 서버 상태를 가져오지 않습니다.  
   하지만 몇 초마다 `offline`, `online`, `unknown` 중  
   하나로 상태가 랜덤하게 변경되는 것을  
   시뮬레이션하고 싶습니다.

3. And to make that work,  
   we need to set up an interval that executes some code  
   that will change that `currentStatus` value  
   every couple of seconds.  
   이를 위해, 몇 초마다  
   `currentStatus` 값을 변경하는 코드를 실행하는  
   인터벌(interval)을 설정해야 합니다.

4. And we could do that with help of the constructor.  
   이를 생성자를 사용하여 설정할 수 있습니다.

5. In there, we can call the built-in `setInterval` function,  
   which is provided by JavaScript,  
   so that's of course not Angular or TypeScript specific.  
   생성자 안에서 JavaScript에서 제공하는  
   기본 함수 `setInterval`을 호출할 수 있습니다.  
   이는 Angular나 TypeScript에 특화된 기능이 아닙니다.

6. And `setInterval` then takes a function,  
   which it will execute every X amount of milliseconds.  
   `setInterval`은 함수와 함께  
   몇 밀리초마다 실행할지를 나타내는 값을 받습니다.

7. And that's the second argument you must pass to `setInterval`,  
   the amount of milliseconds it should wait  
   until it executes this function again.  
   그리고 두 번째 인수는  
   함수를 다시 실행하기 전에 대기할  
   밀리초 단위의 시간입니다.

8. And here, let's say we wanna wait five seconds,  
   which would be 5000 milliseconds.  
   여기에서는 5초를 기다리려고 합니다.  
   이는 5000밀리초에 해당합니다.

9. Now every 5000 milliseconds, every five seconds, therefore,  
   this function will be executed by the browser  
   when the application is running.  
   이제 애플리케이션이 실행 중일 때  
   브라우저가 매 5000밀리초(5초)마다  
   이 함수를 실행합니다.

10. So it's now inside of this function  
    where I want to update `currentStatus`.  
    이제 이 함수 내부에서 `currentStatus`를  
    업데이트하고 싶습니다.

11. And here I wanna generate a random value with `Math.random`.  
    여기에서는 `Math.random`을 사용하여  
    랜덤 값을 생성하려고 합니다.

12. And I then simply wanna check if `random` is smaller  
    than 0.5 because `Math.random` will produce a value  
    between 0 and 1, 1 excluded, so technically 0.9999.  
    그리고 `Math.random`이 0.5보다 작은지 확인합니다.  
    `Math.random`은 0에서 1(1은 제외) 사이의 값을 생성하므로  
    실제로는 0.9999까지 생성됩니다.

13. And if the value that was produced is smaller than 0.5,  
    so in 50% of all cases in the end,  
    I wanna set this `currentStatus` equal to `online`, let's say.  
    생성된 값이 0.5보다 작다면,  
    즉 전체의 50% 확률로,  
    `currentStatus`를 `online`으로 설정하려고 합니다.

14. Else if `random` is smaller than 0.9,  
    so it's bigger than 0.5 but smaller than 0.9,  
    in this case, I wanna set the `currentStatus` to `offline`,  
    and in the remaining 10% of cases,  
    I wanna set `currentStatus` to `unknown`.  
    그렇지 않고 `random`이 0.9보다 작다면,  
    즉 0.5보다 크고 0.9보다 작은 경우에는  
    `currentStatus`를 `offline`으로 설정하고,  
    나머지 10%의 경우에는 `currentStatus`를  
    `unknown`으로 설정합니다.

15. Now, one thing you might wanna consider doing here  
    when working with hard-coded values like this  
    is set up a type that only accepts these kinds of values.  
    이제 이런 하드코딩된 값을 사용할 때,  
    이 값들만 허용하는 타입을 설정하는 것을  
    고려할 수 있습니다.

16. And you can do this in TypeScript  
    by explicitly assigning a type to `currentStatus`,  
    which will disable inference for this property  
    because by default it would infer that `currentStatus`  
    should be of type string.  
    TypeScript에서 `currentStatus`에  
    명시적으로 타입을 할당하여  
    기본적으로 문자열 타입으로 추론되는 것을  
    비활성화할 수 있습니다.

17. But here I wanna be more specific  
    that it's one of these three strings.  
    하지만 여기에서는 좀 더 구체적으로  
    `online`, `offline`, `unknown` 중  
    하나라는 것을 나타내고 싶습니다.

18. And you can do that with TypeScript  
    by disabling the inference for this property  
    by explicitly assigning a type.  
    이를 위해 TypeScript에서 명시적으로 타입을 할당하여  
    속성 추론을 비활성화할 수 있습니다.

19. And then you can set up the three string values  
    that should be accepted as a union type,  
    so separated by that pipe symbol.  
    그런 다음 수락할 세 개의 문자열 값을  
    파이프(`|`) 기호로 구분하여  
    유니온 타입으로 설정할 수 있습니다.

20. And that tells TypeScript that `currentStatus`  
    must be a string that's either `online`, `offline`, or `unknown`.  
    이는 `currentStatus`가 반드시  
    `online`, `offline`, `unknown` 중  
    하나여야 한다고 TypeScript에 명시합니다.

21. And if I had a typo down there,  
    I would quickly see because I would get an error  
    that the type `offine` written like that  
    is not assignable to my type here.  
    만약 아래에서 오타가 발생했다면,  
    TypeScript가 `offine`과 같은 값은  
    허용되지 않는다고 오류를 표시하므로  
    이를 빠르게 확인할 수 있습니다.

22. And that's why you might wanna do that  
    and be a bit more explicit  
    because it can help avoid typos like this.  
    이런 이유로 이를 설정하면 오타를 방지할 수 있어  
    조금 더 명시적으로 작성하는 것이 좋습니다.

23. Well, but with that, we're setting up this interval.  
    어쨌든, 이를 통해 인터벌을 설정했습니다.

24. And now if you save that and you reload,  
    you should see that this value should change  
    from time to time and it's random.  
    이제 저장하고 새로고침하면  
    값이 랜덤하게 시간이 지남에 따라 변경되는 것을  
    확인할 수 있습니다.

25. So of course you can't tell how often it will change  
    to which value, but you see now it's `unknown`  
    and eventually it will change again to `offline` as it seems,  
    at some point it might also be `online`.  
    물론, 값이 얼마나 자주 변경될지는 알 수 없지만,  
    현재는 `unknown` 상태이며,  
    곧 `offline`으로 변경될 수 있습니다.  
    그리고 언젠가는 `online` 상태가 될 수도 있습니다.

26. Now it is. So that's therefore, working.  
    이제 그렇게 되었습니다. 작동하고 있는 것입니다.

27. But that wasn't even the main thing  
    I wanted to do here,  
    though, it is an important step in the right direction.  
    하지만 이것은 제가 여기에서 하고 싶었던  
    주요 작업은 아니었지만,  
    중요한 첫걸음입니다.

---

끝났습니다.
