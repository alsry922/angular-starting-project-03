1. So knowing how to listen to events  
   on the host element and knowing about HostBinding  
   and HostListener is important as an Angular developer.  
   호스트 요소에서 이벤트를 청취하는 방법과  
   `HostBinding` 및 `HostListener`에 대해 아는 것은  
   Angular 개발자로서 중요합니다.

2. There is one other last host element-related feature  
   you should know about though  
   because sometimes in certain situations,  
   you might need programmatic access to the host element.  
   하지만 호스트 요소와 관련된 또 다른 마지막 기능이 있습니다.  
   특정 상황에서 호스트 요소에  
   프로그래밍적으로 접근해야 할 수도 있기 때문입니다.

3. So you might need to interact with it  
   from inside your TypeScript code.  
   따라서 TypeScript 코드 내부에서  
   이를 다뤄야 할 수도 있습니다.

4. For example, let's say here,  
   when we click on the host element,  
   I wanna output some information about it,  
   which obviously is not a real use case.  
   예를 들어, 호스트 요소를 클릭했을 때  
   해당 요소에 대한 정보를 출력한다고 가정해 봅시다.  
   물론, 이것은 실제 사용 사례는 아닙니다.

5. But here in this app I don't have a real use case  
   because it is a feature you won't need that often,  
   but you should still know about it.  
   하지만 이 앱에서는 실제 사용 사례가 없습니다.  
   이 기능은 자주 필요하지 않지만  
   그래도 알아두어야 합니다.

6. So for this demo,  
   let's say we wanna log some host element information  
   whenever it is clicked.  
   그래서 이 데모에서는  
   호스트 요소를 클릭할 때마다  
   해당 요소 정보를 로그로 출력한다고 가정하겠습니다.

7. Now, what you can do to achieve this  
   is you can inject a special value into your component,  
   a value that will be provided by Angular,  
   and you can inject either with the constructor  
   as you learned it for services  
   or with help of that inject function  
   about which you also learned.  
   이를 위해, Angular가 제공하는 특별한 값을  
   컴포넌트에 주입할 수 있습니다.  
   이는 서비스에서 배운 대로 생성자를 사용하거나,  
   `inject` 함수의 도움을 받아 주입할 수 있습니다.

8. And I'll use the latter here, but both would work.  
   여기서는 후자를 사용할 것이지만,  
   두 가지 방법 모두 작동합니다.

9. So for that, I'll add a private property here,  
   which therefore won't be exposed to the template  
   of this component since I don't need access to it there.  
   이를 위해, 여기에서 private 속성을 추가할 것입니다.  
   이 속성은 템플릿에서 접근할 필요가 없으므로  
   컴포넌트 템플릿에 노출되지 않습니다.

10. And I'll name it el, but the name is up to you.  
    저는 이를 `el`이라고 이름 짓겠지만,  
    이름은 원하는 대로 정할 수 있습니다.

11. And the value of that property should then be the result  
    of calling inject,  
    which must be imported from @angular/core, of course.  
    이 속성의 값은 `inject`를 호출한 결과여야 하며,  
    물론 `@angular/core`에서 가져와야 합니다.

12. And to inject,  
    we now have to pass a special class name,  
    the ElementRef class name,  
    which also must be imported from @angular/core.  
    주입하려면 특별한 클래스 이름,  
    즉 `ElementRef` 클래스 이름을 전달해야 하며,  
    이것도 `@angular/core`에서 가져와야 합니다.

13. ElementRef is a class defined by Angular.  
    So it's part of the Angular framework,  
    which defines a reference to some element  
    that's rendered to the page.  
    `ElementRef`는 Angular가 정의한 클래스입니다.  
    이는 페이지에 렌더링된 요소에 대한  
    참조를 정의하는 Angular 프레임워크의 일부입니다.

14. So it's pretty generic  
    because it can refer to any element on the page.  
    이는 페이지의 모든 요소를 참조할 수 있기 때문에  
    매우 일반적입니다.

15. But by injecting it into a component like this,  
    Angular will give you access to the host element  
    of that component.  
    하지만 이렇게 컴포넌트에 주입하면  
    Angular는 해당 컴포넌트의 호스트 요소에  
    접근할 수 있게 해줍니다.

16. So therefore here, we can console.log(this.el).  
    따라서 여기에서 `console.log(this.el)`을 호출할 수 있습니다.

17. And with that, if you save it  
    and you reload, if you click on that app-control element,  
    you get clicked, of course,  
    but you also get that injected ElementRef object,  
    and that is then an object  
    that has a nativeElement property.  
    이를 저장하고 새로고침한 후  
    `app-control` 요소를 클릭하면  
    클릭 로그는 물론, 주입된 `ElementRef` 객체도 출력됩니다.  
    이 객체는 `nativeElement` 속성을 가지고 있습니다.

18. And that property then actually holds your host element.  
    이 속성은 실제로 호스트 요소를 포함합니다.

19. So if I expand that, you see that this is in the end  
    what Angular knows about the host element  
    that's rendered to the DOM.  
    이를 확장하면, Angular가 DOM에 렌더링된  
    호스트 요소에 대해 알고 있는 내용을 확인할 수 있습니다.

20. And it's essentially a collection of properties that exist  
    for all DOM elements.  
    이는 기본적으로 모든 DOM 요소에 존재하는  
    속성들의 모음입니다.

21. And you could now extract information from those properties.  
    이제 이러한 속성에서 정보를 추출할 수 있습니다.

22. You could also change them,  
    though you should be careful about that  
    because you typically don't wanna start changing  
    what's visible on the page programmatically  
    by using the ElementRef.  
    이를 변경할 수도 있지만,  
    `ElementRef`를 사용하여  
    페이지에 표시되는 내용을  
    프로그래밍적으로 변경하는 것은  
    일반적으로 권장되지 않습니다.

23. Instead, you should change what's visible on the page  
    by changing data and using template features  
    as we always did it throughout this course.  
    대신, 데이터 변경과 템플릿 기능을 사용하여  
    페이지에 표시되는 내용을 변경해야 합니다.  
    이는 이 강의에서 계속 배운 방식입니다.

24. But if you need programmatic access to the host element,  
    this is how you can get it:  
    by injecting ElementRef.  
    그러나 호스트 요소에 프로그래밍적으로  
    접근해야 하는 경우,  
    `ElementRef`를 주입하여 접근할 수 있습니다.

---

끝났습니다.
