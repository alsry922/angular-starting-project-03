1. Maybe you recall that in the server status  
   component CSS file, there are some CSS selectors  
   which don't select anything,  
   because I'm looking for a CSS class `status`  
   or `status-online` or `status-offline`.  
   아마 기억하시겠지만, `server-status` 컴포넌트 CSS 파일에는  
   아무 것도 선택하지 않는 CSS 선택자가 있습니다.  
   이는 제가 `status`, `status-online`, `status-offline`  
   클래스들을 찾고 있기 때문입니다.

2. And in that template, those classes don't exist anywhere.  
   그런데 해당 템플릿에는 그런 클래스가 존재하지 않습니다.

3. Instead, what we have in this template  
   is some conditional check with the `@if` statement  
   about which you learned earlier in the course,  
   combined with `else if` to check for an additional condition  
   and `else` to render something that will be rendered  
   if none of these conditions is met.  
   대신, 이 템플릿에는 강의 초반에 배운  
   `@if` 문으로 조건을 확인하는 부분이 있습니다.  
   추가 조건을 확인하기 위해 `else if`와  
   조건이 충족되지 않을 때 렌더링할 내용을 위한  
   `else`가 결합되어 있습니다.

4. But we don't have those CSS classes here.  
   그러나 여기에는 해당 CSS 클래스가 없습니다.

5. Now, my idea with those classes is to add them conditionally  
   to an element here in the template,  
   just as we're outputting some elements conditionally.  
   제가 생각한 아이디어는,  
   조건적으로 렌더링되는 요소처럼  
   해당 클래스도 조건적으로  
   템플릿의 요소에 추가하는 것입니다.

6. Now, to make that work and to actually see  
   that some things rendered conditionally  
   or some class is added conditionally,  
   we, first of all, need to tweak  
   that server status component TypeScript code.  
   이를 작동시키고 조건적으로 렌더링되거나  
   조건적으로 클래스가 추가되는 것을 확인하려면  
   먼저 `server-status` 컴포넌트의 TypeScript 코드를  
   조정해야 합니다.

7. Because in there, I got this `currentStatus` property,  
   and at the moment, it's always set to `online`.  
   그 이유는 `currentStatus`라는 속성이 있는데,  
   현재는 항상 `online`으로 설정되어 있기 때문입니다.

8. Now, my idea with this component  
   is that it should reflect a changing server status.  
   이 컴포넌트의 아이디어는  
   변경되는 서버 상태를 반영하는 것입니다.

9. Now of course, this is just a dummy application here,  
   so we don't actually grab any real server status,  
   but I at least wanna change the current server status  
   every couple of seconds, let's say.  
   물론, 이것은 단순한 데모 애플리케이션이므로  
   실제 서버 상태를 가져오지는 않습니다.  
   하지만 몇 초마다 현재 서버 상태를  
   변경하고 싶습니다.

10. I wanna randomly change it  
    from `online` to `offline` or to `unknown`.  
    이를 `online`, `offline`, `unknown`으로  
    무작위로 변경하려고 합니다.

11. These are the three different status values I wanna support.  
    이것이 제가 지원하려는 세 가지 상태 값입니다.

12. Therefore, what I'll do here is I'll bring back  
    a wrapping div because it's on that div  
    where I wanna add some classes conditionally.  
    그래서 여기에서는 래핑 div를 다시 추가할 것입니다.  
    이 div에 조건적으로 클래스들을 추가하고 싶기 때문입니다.

13. And we can then add a class conditionally  
    or set the class value dynamically  
    with help of Angular's class binding, which looks like this.  
    그런 다음 Angular의 클래스 바인딩을 사용하여  
    클래스 값을 조건적으로 추가하거나  
    동적으로 설정할 수 있습니다.

14. You can bind the `class` property on a div dynamically  
    by using this property binding syntax.  
    이 속성 바인딩 문법을 사용하여 div의 `class` 속성을  
    동적으로 바인딩할 수 있습니다.

15. But under the hood, Angular then actually detects  
    that it's the class you're binding,  
    and it then extends the default property binding syntax  
    for this `class` property, you could say.  
    내부적으로 Angular는 해당 속성이 클래스임을 감지하고,  
    이 `class` 속성을 위한 기본 속성 바인딩 문법을 확장합니다.

16. For example, if you would want to set  
    the `status` class conditionally,  
    you could do it like this.  
    예를 들어, `status` 클래스를 조건적으로 설정하려면  
    다음과 같이 할 수 있습니다.

17. You could set `class.status`,  
    and then for example check if `currentStatus`  
    equals `offline`, like this.  
    `class.status`를 설정한 뒤  
    `currentStatus`가 `offline`인지 확인할 수 있습니다.

18. Now, the `status` class would only be applied to that div  
    if this condition is met,  
    and that is a syntax you saw earlier in the course already,  
    that you can add or remove classes dynamically  
    with help of this syntax.  
    이제 조건이 충족될 경우에만  
    해당 div에 `status` 클래스가 적용됩니다.  
    이 문법은 클래스들을 동적으로 추가하거나 제거할 수 있는  
    방법으로, 강의 초반에 이미 본 문법입니다.

19. So here in this case where server status is `online`,  
    this check here will actually produce `false`,  
    and the `status` class will not be added to this div.  
    따라서 서버 상태가 `online`인 경우,  
    이 조건문은 `false`를 반환하며,  
    `status` 클래스는 해당 div에 추가되지 않습니다.

20. As a result, if you save that and you reload  
    and you then inspect that server status component,  
    you'll see that div in there,  
    this div here inside of the `app-server-status` component,  
    but there is no class on it.  
    결과적으로 이를 저장하고 새로고침한 후  
    `server-status` 컴포넌트를 검사해 보면  
    `app-server-status` 컴포넌트 내부의 div를 볼 수 있지만  
    클래스가 추가되지 않았습니다.

21. Now, if I change my check to check for `online`  
    and will soon make sure  
    that this actually changes dynamically,  
    for the moment, I'll leave it hardcoded.  
    이제 조건을 `online`으로 변경하고  
    곧 이 값이 동적으로 변경되도록 만들겠지만,  
    현재로서는 하드코딩된 상태로 두겠습니다.

22. But if I check for `online` and save this,  
    you'll see that this class is added.  
    그러나 `online`을 확인하고 저장하면  
    해당 클래스가 추가된 것을 볼 수 있습니다.

23. So that's how you can add or set classes dynamically  
    with help of Angular's class-binding feature.  
    이것이 Angular의 클래스 바인딩 기능을 사용하여  
    클래스를 동적으로 추가하거나 설정하는 방법입니다.

24. But that is a syntax you already knew.  
    하지만 이것은 이미 알고 있는 문법입니다.

25. Now, we'll dig a bit deeper  
    and see how else you could use this feature  
    in ways you didn't know about yet.  
    이제 조금 더 깊이 들어가  
    이 기능을 다른 방식으로  
    어떻게 활용할 수 있는지 살펴보겠습니다.

---

끝났습니다.
